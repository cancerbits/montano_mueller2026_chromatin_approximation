---
title: "ML2Cell main"
output: html_document
date: '2025-06-09'
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
```

# 1. SETUP. Import libraries and functions

```{r echo=FALSE}

source("~/R/mlutils_setup.R")


test.datasets=dataset.info$dataset_name[dataset.info$is_test %>% as.logical]


#while transitioning to full config dependency, we import many variables into the workspace

list2env(dataset.info, .GlobalEnv)

source("~/R/nanorf_utils.R")
source("~/R/atacutils.R")
source("~/R/utilities.R")

if(is.null(dataset.info$selected_celltype_list){
selected.celltype.list=c( "HSC", "MPP","LMPP", "CD34 Bone Marrow", "CD8Tcell", "Bcell","CMP","MEP","Ery" ) %>% rev
}else{
 selected.celltype.list=dataset.info$selected_celltype_list 
}
```

## Setup of bash scripting tools

# Run the next block first., if there are problems with miniforge3 or conda, run this block. 
```{bash echo=FALSE}
wget https://github.com/conda-forge/miniforge/releases/download/25.3.0-3/Miniforge3-25.3.0-3-Linux-x86_64.sh
bash /home/rstudio/Miniforge3-25.3.0-3-Linux-x86_64.sh -b
```


```{bash echo=FALSE}
source /home/rstudio/miniforge3/etc/profile.d/conda.sh 
conda activate /opt/conda/envs/py37
deeptools --version
```

# 2. DATASET COLLECTION AND PREPROCESSING

## Programmatically retrieve and assemble all test datasets, and filter 

```{r}

################################################################################
# Deciide whether to only process tests and not other datasets.
################################################################################

if(dataset.info$onlytest){
relevant.datasets=which(as.logical(dataset.info$is_reference) | as.logical(dataset.info$is_test))
}else{
  relevant.datasets=1:length(dataset.info$dataset_name)
}


all.raw.datasets.list=lapply( relevant.datasets, function(j){
  fcat("dataset",dataset.info$dataset_name[j])
  
################################################################################
#importing reference mapped counts
#when only one reference, it is assumed that the self path actually provides the reference peaks so the self path is used.
################################################################################

list2env(import.counts(j, dataset.info, recreate=T), .GlobalEnv)
  
### get the annotation peak info for the individual dataset. 
annotation.peaks.self=counts.to.self[, rangefields]
annotation.peaks.ref=counts.to.ref[, rangefields]


#retrieve the ids of the experiments from the counts table removing the gtf fields

ids=colnames(counts.to.self) %>% setdiff(., rangefields)

################################################################################
# Retrieve metadata
################################################################################
metalist.full=get.metadata.from.dataset(j, dataset.info=dataset.info, exclude=NULL)#dataset.info$exclude_cell_type, celltype.var=dataset.info$cell_type_variable)

metalist=get.metadata.from.dataset(j, dataset.info=dataset.info, ids=ids, exclude=dataset.info$exclude_cell_type, celltype.var=dataset.info$cell_type_variable)

if(filter.frip){
metalist=metadata.filter.frip(metalist, frip.threshold=as.numeric(dataset.info$frip_threshold[j]))
}

#locate samplesheet runs that did not make it to the dataset list.

missing.experiments <- setdiff(rownames(metalist.full$metadata.main), ids)

# exclude cell types

ds.list=list(name=dataset.info$dataset_name[j],
  counts.self=counts.to.self[, metalist$included.ids],
  counts.ref=counts.to.ref[, metalist$included.ids],
  metalist=metalist,
  annotation.peaks.self=annotation.peaks.self,
  annotation.peaks.ref=annotation.peaks.ref,
  ids=metalist$included.ids,
  missing.experiments=missing.experiments
  )

}) %>% givename(., dataset.info$dataset_name[relevant.datasets])


```


# 3. MERGE DATASETS INTO ONE COUNTS AND METADATA MATRIX. 


```{r}

include.external=T
#size of dataset.list and id.list must match
simpleCache(paste_("prepared_dataset_", ifelse(filter.frip, "filtered_fripscore", "raw_unfiltered_fripscore"), "_version", analysis.version),{
counts= lapply(all.raw.datasets.list, function(x) x$counts.ref) %>% Reduce(cbind, .)
metadata= lapply(all.raw.datasets.list, function(x) x$metalist$metadata.complete %>% as.data.frame) %>% bind_rows
metadata=generate_treatment_columns3(metadata, dataset.info=dataset.info)

id.list=lapply(all.raw.datasets.list, function(x) x$ids ) 


testids=id.list[dataset.info$is_test] %>% Reduce(c,.)
refids=id.list[dataset.info$is_reference] %>% Reduce(c,.)
extids=id.list[dataset.info$is_external] %>% Reduce(c,.)

if(include.external){
  fcat("including external datasets")
analysis.ids=Reduce(c, id.list)
}else{
analysis.ids=c(refids, testids)  
}

alldatasets=list(counts=counts,
  meta=metadata,
  analysis.ids=analysis.ids,
  testids= testids,
  refids= refids,
  extids=extids,
  annotation.peaks=all.raw.datasets.list[[1]]$annotation.peaks.ref
  ) 
alldatasets
}, assignToVar="merged.datasets.raw", reload=T)

list2env(merged.datasets.raw, .GlobalEnv)
gc()

dump.table(annotation.peaks)


################################################################################
# prepare special variables containing the target and test experiments
################################################################################


target.ids=meta %>% filter(Condition==!!config$target_cell_type) %>% pull(Experiment)

test.ids.list=lapply(dataset.info$dataset_name[as.logical(dataset.info$is_test)], function(x){
  
  meta %>% dplyr::filter(grepl(x, dsname)) %>% pull(Experiment)
  
}) %>% givename(dataset.info$dataset_name[as.logical(dataset.info$is_test)])


## meta2 at this point has been made equivalent to meta.

simpleCache("formatted.metadata" %>% addversion, {
meta2= generate_treatment_columns3(meta, dataset.info=dataset.info) %>% annotate.rbc
meta2}, assignToVar="metadata.alldatasets.formatted", reload=T)

dump.table(metadata.alldatasets.formatted)

################################################################################
# cleanup of data not needed
################################################################################

rm(all.raw.datasets.list)
gc()

```

### 4.  Apply global filter to samples

```{r}
################################################################################
# apply peak filtering
################################################################################

simpleCache(paste_("counts_filter", filter.peaks, ifelse(filter.frip, "filtered_fripscore", "raw_unfiltered_fripscore"), "_minexpts", min.expts, "minreads",min.reads, "analysisversion", analysis.version), {
if(filter.peaks){
  peak.pass=(((counts >=min.reads) %>% apply(., 1, sum))>=min.expts) %>% table %>% as.data.frame %>%  givecolnames(., nms=c("passed", "freq")) %>% col2names(., "passed")
  fcat("Min ", min.expts, " experiments with min ", min.reads, " reads.\nPeaks passing filter: ",peak.pass["TRUE","freq"], "\nPeaks failing filter: ", peak.pass["FALSE","freq"], "\nPercentage filtered out: ", ( peak.pass["FALSE","freq"]*100/(peak.pass["FALSE","freq"]+peak.pass["TRUE","freq"])) %>% sprintf(.,fmt = "%.2f" ), "%")

  get.trues=function(x) x[x]
  peak.set=(((counts >=min.reads) %>% apply(., 1, sum))>=min.expts) %>% get.trues %>% names 
 counts.filtered=counts[peak.set, ]
 me=min.expts
 mr=min.reads
}else{
  counts.filtered=counts
  peak.set=rownames(counts)
  me=0
  mr=0
}
filterdata=list(counts.filtered=counts.filtered, peak.set=peak.set, min.expts=me, min.reads=mr)
filterdata
}, assignToVar="filterdata" , reload=T) 

list2env(filterdata, .GlobalEnv)
```


### 5a. annotate all peaks for closest genes and overlapping promoters


```{r}
# make sure annotation.peaks is in the workspace
peak.annotation.data=get.global.peak.annotations()
list2env(peak.annotation.data, .GlobalEnv)
list2env(peak.annotation.data$peak.gene.annotations, .GlobalEnv)


```



# 5. Run global  DEseq2

```{r}
simpleCache(paste0("dds_alltests_plusreference_", ifelse(filter.peaks, "filtered_", "unfiltered")) %>% addversion, {

dds     <- DESeqDataSetFromMatrix(countData=counts.filtered[, analysis.ids]  , colData=meta[analysis.ids,] %>% dplyr::mutate(dsname=factor(dsname)), design=~dsname+1)

dds     <- estimateSizeFactors(dds)

    rld      <- vst(dds, blind=F)
    
assay(dds, vst_name) <- assay(rld)

################################################################################
# prepare  normalised peaks matrix
################################################################################

dds

}, assignToVar="dds", reload=T)


simpleCache("vsd_version" %>% addversion,{
vsd= assay(dds, vst_name)
}, assignToVar="vsd", reload=T)

simpleCache(paste0("normalised_peak_values_table_version_",analysis.version), { 
  
norm.peak.vals= annotation.peaks %>% dplyr::filter(Geneid %in% peak.set)  %>% col2names(., "Geneid") %>% cbind(., vsd)
}, assignToVar="norm.peak.vals", reload=T )


dump.table(norm.peak.vals)


simpleCache(paste0("normalised_peak_values_transposed_table_version_",analysis.version), {
norm.peak.vals.t= t(vsd)

norm.peak.vals.t

}, assignToVar="norm.peak.vals.t", reload=T)
```

### 6. FRiP score plots to spot quality outliers


```{r, fig.height=6, fig.width=8}

meta=metadata.alldatasets.formatted

rdf=meta[refids, c("dsname",dataset.info$cell_type_variable,"frip.score","reads_mapped_percent","reads_mapped"  )] %>% arrange(frip.score) %>% dplyr::mutate(frip.rank=1:n())

rbars=ggplot(rdf, aes(x=frip.rank, y=frip.score, fill=!!sym(dataset.info$cell_type_variable)))+
  geom_col()+
  geom_hline(yintercept=as.numeric(dataset.info$frip_threshold), linetype="dashed")+
  theme_classic()+
  scale_fill_manual(values=allcolors[[dataset.info$cell_type_variable]])+
    theme(
    legend.position = "bottom",            
    legend.direction = "horizontal",      
  )


tdf=meta[, c("dsname",dataset.info$cell_type_variable,"frip.score","reads_mapped_percent","reads_mapped"  ), drop=F] %>% group_by(dsname) %>% arrange(frip.score) %>% dplyr::mutate(frip.rank=1:n()) %>% ungroup 


tbars=ggplot(tdf, aes(x=frip.rank, y=frip.score, fill=!!sym(dataset.info$cell_type_variable)))+# !!sym(dataset.info$cell_type_variable)))+
  geom_col()+
  theme_classic()+
  scale_fill_manual(values=allcolors[[dataset.info$cell_type_variable]])+facet_wrap(~dsname,  scale="free_x")+theme(legend.position="bottom")

  
sca=1

tpdf(path=config$plotpath, "barplot_fripscore_per_dataset", wi=pw*sca*2, he=pw*sca*2)
tbars

dev.off()


layout=c(
"AAAA
AAAA
BBBB
BBBB")

qbarplots=wrap_plots(A=rbars, C=tbars, design=layout)


qbarplots

```


# 7.  Execute reference PCA and project samples onto PCA or perform joint PCA

```{r runpca,fig.height=24, fig.width=10}

################################################################################
# actually project only tests onto reference
################################################################################
simpleCache(paste0("pcadata_projected_tests_to_referece", analysis.version),{
  
  test.dataset.indices=which(as.logical(dataset.info$is_test))

processed.test.indices=which(relevant.datasets %in% test.dataset.indices)
  
pca.data=lapply(processed.test.indices, function(x){
  fcat(all.raw.datasets.list[[x]]$metalist$metadata.complete$dsname[1])
  
pj=projectsamples(dds, refids=refids, testids=all.raw.datasets.list[[x]]$ids, label=all.raw.datasets.list[[x]]$metalist$metadata.complete$dsname[1], return.reference=ifelse(x==processed.test.indices[1], T, F))

}) %>% bind_rows
  
pca.data
}, assignToVar="pca.data.test", reload=T)


################################################################################
# project every dataset onto the reference pca
################################################################################

simpleCache(paste0("pcadata_complete_analysis_test_and_external_experiments", analysis.version),{
  
  dataset.indices=which(!dataset.info$is_reference)

  
processed.test.indices=which(relevant.datasets %in% dataset.indices)
  
pca.data=lapply(processed.test.indices, function(x){
  fcat(all.raw.datasets.list[[x]]$metalist$metadata.complete$dsname[1])
  
pj=projectsamples(dds, refids=refids, testids=all.raw.datasets.list[[x]]$ids, label=all.raw.datasets.list[[x]]$metalist$metadata.complete$dsname[1], return.reference=ifelse(x==processed.test.indices[1], T, F))

}) %>% bind_rows
  
pca.data
}, assignToVar="pca.data.projected.all", reload=T)


################################################################################
# generate joint pca of all conditions together
################################################################################

pca.data.joint=simplePCA(dds, label="pca_all_samples")

```


# 8. PCA component plots


```{r fig.height=3, fig.width=3}

################################################################################
# select one of the PCAs above for follow up analysis
################################################################################
pca.data=pca.data.joint %>% generate_treatment_columns3(., dataset.info)

getp=Vectorize(function(samplename) strsplit(samplename, split="_")[[1]][2], USE.NAMES=F)

allcombs<-combn(1:numcomp,2)

pca.data=pca.data %>% dplyr::mutate(celltype.original=celltype)

### very specifically to highlight validation dataset


validation.dataset="Seruggia2025-3"
pca.data=pca.data %>% dplyr::mutate(celltype=ifelse(dsname==validation.dataset, "validation", celltype))


allplots=lapply(1:ncol(allcombs), function(xx){
  pc1=allcombs[1,xx];
  pc2=allcombs[2,xx];

#make all hulls at once    
  alltypes=pca.data %>% filter(dscategory=="reference") %>% pull(Condition) %>% unique
  allhulls=lapply(alltypes, function(xx){
      df=pca.data %>% dplyr::filter(Condition==xx) %>% dplyr::select(!!sym(paste0("PC", pc1)), !!sym(paste0("PC",pc2)), celltype) 
hulldf= df[chull(df), ]
    hulldf
  }) %>% givenames(., alltypes) %>% Reduce(rbind, .)

  
allcentroids= pca.data %>% group_by(celltype) %>% summarise(meanx=mean(!!sym(paste0("PC", pc1))), meany=mean(!!sym(paste0("PC",pc2)))) 
    
    percentVar    <- round(attr(pca.data, "percentVar")$percentVar)
    plot_subtitle <- ifelse(n_top_var==Inf, "All genes", paste("Top", n_top_var, "genes"))
    pl <- ggplot(pca.data, aes(!!sym(paste0("PC",pc1)), !!sym(paste0("PC", pc2)), label=paste0(" ", celltype, " "))) +
        geom_point(aes(color=celltype, shape=dsname)) +
      geom_polygon(data=allhulls, aes(x=!!sym(paste0("PC",pc1)), y=!!sym(paste0("PC", pc2)), group=celltype, color=celltype, fill=celltype, alpha=!!alph ))+
        geom_text_repel(data= allcentroids, inherit.aes=F, aes(x=meanx, y=meany, color=celltype, label=celltype) , check_overlap=FALSE, hjust="inward", max.overlaps=30, min.segment.length = 0) +
        xlab(paste0("PC", pc1))+ 
        ylab(paste0("PC", pc2))+
        theme(legend.position="top",
            panel.grid.major = element_blank(),
            panel.grid.minor = element_blank(),
            panel.background = element_blank(),
            panel.border = element_rect(colour = "black", fill=NA, size=1))+
            scale_color_manual(values=allcolors$celltype)+
    scale_fill_manual(values=allcolors$celltype)+NoLegend()
  
    
    pl
})


################################################################################
# make pca components grid plot
################################################################################


allplots[[(length(allplots)+1)]]= manual.legend(allcolors, pname="celltype", size=3)

    sca=5
    tpdf(path= config$plotpath, paste0("PCAbiplot_grid_wtext") %>% addversion, wi=pw*sca*1.2, he=pw*sca*1.4)
print((allplots %>% Reduce('+', .))+plot_layout( ncol=4, nrow=6))
    dev.off()


```

# 9. Feature selection on PCA for classification of cell identities (Random Forest workflow)

Use Random forest to classify cell types and recover variable importance, and what PCs are relevant for classifying all cell types


```{r}

# execute 2 step random forest workflow to select high importance compoonents

rlist=random.forest.workflow(package.vars(pca.data, refids, allcolors), dataset.info, recreate=T)

list2env(rlist, .GlobalEnv)

var.importance=rlist$var.importance.arranged %>% as.data.frame

# generate output tables
dump.table(var.importance, row.names=T)

dump.table(confusion.training2)
dump.table(confusion.training2i)

```


# 10. Analysing peaks with highest loadings in relevant PCs for genes and tf targets

```{r}

relevant.chromosomes=paste0("chr", c(1:22, "X"))
selected.pc.list=union(paste0("PC", 1:10), informative.pcs)


simpleCache(paste_("pcalist_version", analysis.version),{
  

pca.list      <- plotPCA_vst(dds, ids=refids, metadata=meta, assay=vst_name, ntop=n_top_var)
pca.list}, assignToVar="pca.list", recreate=T)

loadings.pca.peaks=cbind(annotation.peaks, pca.list[[2]][[2]])
relevant.chromosome.colors= rainbow(length(relevant.chromosomes)) %>% givename(., relevant.chromosomes)
allcolors$Chr=relevant.chromosome.colors
allchrs=loadings.pca.peaks %>% pull(Chr) %>% unique
missing.chrs=setdiff(allchrs, relevant.chromosomes)
loadings.pca.peaks.filtered= loadings.pca.peaks %>% dplyr::filter(Chr %in% relevant.chromosomes)  

rank.loadings.abs= function(pc) loadings.pca.peaks.filtered  %>% dplyr::mutate(abspc=abs(!!sym(pc))) %>% arrange(-abspc) %>% dplyr::mutate(rank=1:n())

rank.loadings.direct= function(pc) loadings.pca.peaks.filtered %>% arrange(-!!sym(pc)) %>% dplyr::mutate(rank=1:n())

loadings.pca.peaks.fewpcs= loadings.pca.peaks.filtered %>% dplyr::select(1,2,3,4, selected.pc.list) 
simpleCache(paste0("allcurves_toploadings_version_", analysis.version),{ 
allcurves=lapply(selected.pc.list, function(xx){
loadings.pca.peaks.ranked.abs=loadings.pca.peaks.fewpcs  %>% dplyr::mutate(abspc=abs(!!sym(xx))) %>% arrange(-abspc) %>% dplyr::mutate(rank=1:n())
loadings.pca.peaks.ranked.normal=loadings.pca.peaks.fewpcs  %>% dplyr::arrange(-!!sym(xx)) %>% dplyr::mutate(rank=1:n())
#find the first inflection point at which the the derivative
elbowcurve=loadings.pca.peaks.ranked.abs$abspc[1:NUMTOPLOADINGS]
rranks=loadings.pca.peaks.ranked.abs$rank

elbowcurve.normalised=(elbowcurve-min(elbowcurve))/ max((elbowcurve-min(elbowcurve)))
#dilute the tail by exponentiation
elbowcurve.normalised.ewp2=elbowcurve.normalised*elbowcurve.normalised

inflection.point= max(which(elbowcurve.normalised.ewp2>0.05))
print(inflection.point)
splitsdratio=function(vec, granularity=1){
rat=vector()
stepp=vector()
allsteps=seq(1, length(vec), granularity)
for(x in 1:length(allsteps)){
 
  stepp[x]=allsteps[x]
  rat[x]= sd(vec[1:allsteps[x]])/sd(vec)
  
  
}
  return(list(x=stepp,y=rat))
}

splitwilcox=function(vec, granularity=1){
rat=vector()
stepp=vector()
allsteps=seq(1, length(vec), granularity)
for(x in 1:length(allsteps)){
 
  stepp[x]=allsteps[x]
  rat[x]= -log(wilcox.test(vec[1:allsteps[x]], vec[(allsteps[x]+1):length(vec)])$p.value)
    
  
}
  return(list(x=stepp,y=rat))
}

splitmedian=function(vec, granularity=1){
rat=vector()
stepp=vector()
allsteps=seq(1, length(vec), granularity)
for(x in 1:length(allsteps)){
 
  stepp[x]=allsteps[x]
  rat[x]= median(vec[1:allsteps[x]])- median(vec[(allsteps[x]+1):length(vec)])
    
  
}
  return(list(x=stepp,y=rat))
  }
  


plt=ggplot()+geom_path(data=loadings.pca.peaks.ranked.abs, aes(x=rank, y=abspc, color=factor(Chr, levels=relevant.chromosomes)))+
  ggtitle(xx)+
  scale_color_manual( values=allcolors$Chr )+
  geom_vline(xintercept=inflection.point, color="red")+
  theme_classic()+
  NoLegend()
res=list(plot=plt, curve=loadings.pca.peaks.ranked.abs[1:inflection.point, ])

}) %>% givename(., selected.pc.list)# 

allcurves}, assignToVar="allcurves", recreate=T)


################################################################################
# preapere plot with peak loadings
################################################################################

sca=3
tpdf(path=config$plotpath, paste_("lineplot_peak_loadings_all_informative_pcs_loadings_w_cutoff_version", analysis.version), wi=pw*sca, he=pw*sca)
print(lapply(allcurves, function(x) x$plot) %>% Reduce('+',.)+manual.legend(allcolors, pname="Chr"))
dev.off()



```

# 10. Calculate distances to target based on PCA, for different datasets

```{r fig.height=4, fig.width=8}
################################################################################
# functions to calculating centroids and distances tot target from the pca data
################################################################################

pca.data$Condition= gsub("_REP[0-9]", "", pca.data$Condition)
pca.data$Condition= gsub("_ds[0-9]", "", pca.data$Condition)
dspairings=list(
 Ery=c("Corces2016", "Ludwig2019"),
 Mono=c("Corces2016", "Ramirez2017"),
 NKcell=c("Corces2016", "Li2020") 
  
)

scas=list(
 Ery=c(2.5,1.2 ),
 Mono=c(2.5,1.6),
 NKcell=c(2.5, 1.2) 
  
)

allcells=pca.data %>% dplyr::filter(dscategory=="reference") %>% pull(Condition) %>% unique
all.dists=lapply(allcells, function(target_cell_type){

pcnames=informative.pcs

targetdf.pca= (pca.data  %>% dplyr::filter(celltype==!!target_cell_type))

targetcentroid.pca= targetdf.pca[, pcnames] %>% colMeans

distance.to.centroid.pca= function(vec) (dist(rbind(c(vec), targetcentroid.pca), method="euclidean") %>% as.numeric)

get.distances.to.target= function(vec) (dist(rbind(vec,targetdf.pca[, pcnames]), method="euclidean") %>% as.matrix)

distance.to.closest.pca= function(vec) min((dist(rbind(vec,targetdf.pca[, pcnames]), method="euclidean") %>% as.matrix)[2:(nrow(targetdf.pca)+1),1]) %>% as.numeric


dists.centroid.pca=lapply(1:nrow(pca.data), function(rr){
  
distance.to.centroid.pca(pca.data[rr, pcnames])  
}) %>% Reduce(c,.)

dists.closest.pca=lapply(1:nrow(pca.data), function(rr){
  
distance.to.closest.pca(pca.data[rr, pcnames])  
}) %>% Reduce(c,.)


dists.test=lapply(1:nrow(targetdf.pca), function(re){
  
distance.to.closest.pca(targetdf.pca[re, pcnames])  
}) %>% Reduce(c,.)

simpleCache(paste_("pca.data_PCA_distance_calculation_version_target_",target_cell_type, analysis.version), {

pca.data=pca.data %>% dplyr::mutate(target.cell.type=target_cell_type, dist.to.centroid.pca=dists.centroid.pca, dist.to.closest.pca=dists.closest.pca)
pca.data

}, assignToVar="pca.data", recreate=T)

if(target_cell_type %in% names(dspairings)){
  fcat("plotting", target_cell_type)
  
pllll<-ggplot(pca.data %>% dplyr::filter(dsname %in% dspairings[[target_cell_type]], !grepl("LPS", Condition)), aes(x= factor(Condition, levels=names(allcolors[["Condition"]])), y=dist.to.centroid.pca, color=Condition))+geom_point(alpha=0.6, color="black")+facet_wrap(~factor(dsname, levels=dspairings[[target_cell_type]]),  scales="free_x" )+labs(title=target_cell_type)+theme_minimal()+theme(
  axis.text.x = element_text(
    angle = 90,        # keep them horizontal (or set to 45/90 if rotated)
    vjust = .5,        # push labels down toward the x axis
    hjust = 1       # center them horizontally
  )   )+xlab("")+ylab("")#+scale_color_manual(values=allcolors[["Condition"]])+NoLegend()

tpdf(paste0("pointplot_distotarget_", target_cell_type), wi=pw*scas[[target_cell_type]][1], he=pw*scas[[target_cell_type]][2])
print(pllll)
dev.off()

}else{
 pllll<-NULL 
}

list(pllll, pca.data)
})

tpdf(paste0("pointplot_distotarget_panel"), wi=pw*2.5, he=pw*4.5)

print(lapply(all.dists, function(x) x[[1]]) %>% Reduce('/', .))

dev.off()

```

# 11. Generalised DE (each vs all) to any variables

```{r}

colData(dds) = DataFrame(pca.data %>% dplyr::select(!contains("PC")) %>% dplyr::mutate(cellid=paste0(seruggiacompress(dsname), "-", testcompress(celltype), na2nothing(rbc.round1), na2nothing(rbc.round2))))

varr="dsname"

allids= colData(dds) %>% as.data.frame %>% pull(varr) %>% unique

simpleCache(paste0("allcontrasts_of_", varr, "_eachvsall_", analysis.version), {
allres=lapply(allids, function(target){
dds$condition_vs_rest <- factor(ifelse(dds[[varr]] == target, target, "Rest"))

# Re-run the DESeq pipeline with the new condition
design(dds) <- ~ condition_vs_rest

simpleCache(paste0("contrast_ofvariable_", varr, "_",target, "_vs_all_", analysis.version), {
  dds <- DESeq(dds)
# Extract the results again with the correct contrast
res <- results(dds, contrast = c("condition_vs_rest", target, "Rest"))
res
}, assignToVar="res", reload=T)
res
}) %>% givename(., allids)

allres}, assignToVar="allres", reload=T)

```

# 12. Perform DE peak analysis of the invitro conditions to understand the contributions of the different reagents using the reference peaks
```{r, fig.width=6, fig.height=16}


simpleCache("target_DE_classlist_test" %>% addversion, {
#automate
positives=list(
  Round1=list(classvar="round", targets=c("Round1")),
  Round2=list(classvar="round", targets=c("Round2")),
   epo1=list(classvar="epo.1", targets=c("3")),
  epo2=list(classvar="epo.2", targets=c("3")),
    insulin.heparin1=list(classvar="insulin.heparin.1", targets=c("1")),
  hydrocortisone1=list(classvar="hydrocortisone.1", targets=c("1")),
  insulin.heparin2=list(classvar="insulin.heparin.2", targets=c("1")),
  hydrocortisone2=list(classvar="hydrocortisone.2", targets=c("1")),
  epo.only=list(classvar="tmnt.full", targets=c("100_100", "300_100", "100_300", "300_300")),
     hydrocortisone.on=list(classvar="tmnt.full", targets=c("101_101", "301_101", "101_301", "301_301")),
         insulin.heparin.on=list(classvar="tmnt.full", targets=c("110_110", "310_110", "110_310", "310_310")),
  all.on=list(classvar="tmnt.full", targets=c("111_111", "311_111", "111_311", "311_311"))
  )

}, assignToVar="positives.invitro", reload=T)

colData(dds)= DataFrame(pca.data)

allinvitro= colData(dds) %>% as.data.frame %>% dplyr::filter(grepl("Round",celltype) ) %>% arrange(round) %>% pull(Experiment)

dds.invitro= dds[,allinvitro]

par.deseq2.invitro.eachvsall=parallel::mclapply(1:length(positives.invitro), function(x, dd, allpos, pd){
  
  lab=names(allpos)[x]
  classvar=allpos[[x]]$classvar
  levs=c(lab, "Rest")
  is.target= function(x, targets) fifelse(x %in% targets, levs[1], levs[2])
  
  
simpleCache::simpleCache(paste0("deseq2_invitro_target-",lab, "_vsrest_positivesid", digest::digest(allpos),"_ddsid_",digest::digest(dd),  "analysis", analysis.version), {

dd[["target_vs_rest"]] <- factor(is.target(dd[[classvar]], allpos[[x]]$targets), levels=levs)

# Re-run the DESeq pipeline with the new condition
design(dd) <- ~target_vs_rest
dd <- DESeq(dd)  
res <- results(dd, contrast = c("target_vs_rest", levs[1], levs[2]))  

 }, assignToVar="res", reload=T)
  
  
  },allpos=positives.invitro,dd=dds.invitro, mc.cores=1, mc.cleanup=T)




################################################################################
#format results
################################################################################

all.invitro.deseq2.filtered=lapply(1:length(par.deseq2.invitro.eachvsall), function(x){
trgts=strsplit(par.deseq2.invitro.eachvsall[[x]]@elementMetadata[3,2], split=" ")[[1]][c(4,6)]

tab=as.data.frame(par.deseq2.invitro.eachvsall[[x]]) %>% dplyr::mutate(target=trgts[1], reference=trgts[2], contrast=paste0(trgts[1], "_vs_",trgts[2] )) %>% filter(padj<=0.05, log2FoldChange>=.5) %>% arrange(-log2FoldChange) %>% names2col(., "Geneid")

rownames(tab)=NULL
tab
  
}) %>% bind_rows()




################################################################################
#collect subgroups' relevant peaks and closest genes
################################################################################

all.closest.genes.deseq2.invitro=lapply(1:length(positives.invitro), function(x){

  all.invitro.deseq2.filtered %>% dplyr::filter(target==names(positives.invitro)[x]) %>% annotate.close.genes(.) %>% pull(closest.tss) %>% removenas
    
}) %>% givename(., names(positives.invitro))


all.diff.peaks.deseq2.invitro=lapply(1:length(positives.invitro), function(x){

  
  all.invitro.deseq2.filtered %>% dplyr::filter(target==names(positives.invitro)[x]) %>% annotate.close.genes(.) %>% pull(Geneid) %>% removenas
    
  
}) %>% givename(., names(positives.invitro))


he.deseq2.invitro=get.hyper.enrichments(all.closest.genes.deseq2.invitro,gsetpars=gsetpars[1:3], make.heatmap=F, make.barplot=T )


he.deseq2.invitro$barplots[[3]]


```



# 13. make heatmap of the invitro DE peaks.

```{r}

################################################################################
# prepare annotation of the peaks, to check overlaps 
################################################################################
invitro.table=all.invitro.deseq2.filtered %>% select(Geneid, target)
peak.vector.invitro=all.diff.peaks.deseq2.invitro %>% Reduce(c, . ) %>% unique 


all.signal.peaks.celltypes=all.peaks.celltypes.deseq2 %>% Reduce(c, .)


is.signal.peak=lapply(peak.vector.invitro, function(x) x %in% all.signal.peaks.celltypes) %>% Reduce(c, .)
is.target.signal.peak=lapply(peak.vector.invitro, function(x) x %in% target.signal.peaks) %>% Reduce(c, .)


target.table=  deseq2table.celltypes.filtered %>% select( Geneid, target)

#target.table= collective.aucs.celltypes %>% dplyr::filter(auc>= auc.thresh) %>% select( Geneid, target)
  matches=match(peak.vector.invitro, target.table$Geneid)
  
  is.celltype <- ifelse(!is.na(matches), target.table$target[matches], NA)
  
### barplot of frequencies of in vitro peaks that appear in cell types
  ctdata=is.celltype %>% table %>%  coerce.to.matrix %>% as.data.frame %>% givecolnames(., c(1,2), nms=c("celltype", "frequency"))
  
  ordcelltypes= ctdata %>% arrange(-frequency) %>% pull(celltype)
  ggplot(ctdata, aes(x=factor(celltype, levels=ordcelltypes), y=frequency))+geom_col()+rotatex(90)
  

deconv.annotation=apply(create_logical_matrix(factor(is.celltype)), c(1,2), function(x) ifelse(is.na(x), FALSE, x)) %>% giverownames(., peak.vector.invitro) %>% as.data.frame

deconv.annotation$invitro.category=invitro.table$target[match(rownames(deconv.annotation), invitro.table$Geneid) ]

pi.seriated=seriation::get_order(seriation::seriate(deconv.annotation, margin=1, method="PCA"))


invitro.peak.annot=is.celltype %>% coerce.to.matrix %>% as.data.frame %>% givecolnames(., nms="celltype") %>% giverownames(., peak.vector.invitro)



allcolors=append(allcolors, create_colored_list(factor(is.celltype)))

all.matrix.numbers=get.sample.peakvals(peakid=peak.vector.invitro,samples=allinvitro) %>% giverownames(., allinvitro )

pi.seriated.matrix=seriation::get_order(seriation::seriate(all.matrix.numbers %>% t, margin=1, method="PCA"))



peaks.intersect=peak.vector.invitro[apply(deconv.annotation, 1, sum)>0]

#peaks.intersect=peaks.intersect[seriation::get_order(seriation::seriate(deconv.annotation[peaks.intersect, ], margin=1, method="PCA"))]
peaks.intersect=target.table %>% dplyr::filter(Geneid %in% peaks.intersect) %>% arrange(factor(target, levels=ordcelltypes)) %>% pull(Geneid) %>% unique


peaks.absent=peak.vector.invitro[match(peak.vector.invitro[apply(deconv.annotation, 1, sum)==0], peak.vector.invitro)]    


###all together intersect followed by  absent
clusterthis=T
sca=1.5
hm.clustered.ordered=ComplexHeatmap::pheatmap((all.matrix.numbers %>% t)[c(peaks.intersect, peaks.absent), ,drop=F], annotation_col=pca.data[allinvitro,] %>% select( all_of(dataset.info$annotvars))  ,scale="row", breaks=seq(-2,2, 0.1), gaps_row=length(peaks.intersect), show_colnames=F, show_rownames=F, cluster_col=clusterthis, cluster_row=F, use_raster=T, annotation_colors=allcolors, annotation_row=deconv.annotation[c(peaks.intersect, peaks.absent),c(as.character(ordcelltypes), "invitro.category") ,drop=F] )

tpdf(path=config$plotpath,paste_("sheatmap_deseq2peaks_invitro_allsamples_", ifelse(clusterthis, "clustered","nocluster"), "_match_nonmatch") %>% addversion, he=pw*sca*2, wi=pw*sca*2) 
print(hm.clustered.ordered)
dev.off()


###all together seriated
sca=1.5
hm.clustered.invitro=ComplexHeatmap::pheatmap((all.matrix.numbers %>% t)[peak.vector.invitro[pi.seriated.matrix], ,drop=F], annotation_col=pca.data[allinvitro,] %>% select( all_of(dataset.info$annotvars))  ,scale="row", breaks=seq(-2,2, 0.1), show_colnames=F, show_rownames=F, cluster_col=T, cluster_row=F, use_raster=T, annotation_colors=allcolors, annotation_row=deconv.annotation[peak.vector.invitro[pi.seriated.matrix], ,drop=F] %>% as.data.frame)

tpdf(path=config$plotpath,paste_("heatmap_deseq2peaks_invitro_allsamples_clustered") %>% addversion, he=pw*sca*2, wi=pw*sca*2) 
print(hm.clustered.invitro)
dev.off()


hm.unclustered=ComplexHeatmap::pheatmap(all.matrix.numbers[sample.arrangement,] %>% t, annotation_col=pca.data[sample.arrangement,] %>% select( all_of(dataset.info$annotvars)),scale="row", annotation_row=high.peak.annot[hmpeaks, ] %>% select(target), breaks=seq(-2,2, 0.05), show_colnames=F, show_rownames=F, cluster_col=F, cluster_row=F, annotation_colors=allcolors, use_raster=T)
obj.unclustered=ComplexHeatmap::draw(hm.unclustered)
tpdf(path=config$plotpath,paste_("pheatmap_highsignalpeaksinvitro_tests_nocluster") %>% addversion, he=pw*sca*2, wi=pw*sca*1.5) 
print(hm.unclustered)# ,clustering_distance_cols = "correlation", clustering_distance_rows = "correlation")) 
dev.off()

```

# 14. Characterisation of DARs in cell types via DESeq2

```{r, fig.width=6, fig.height=12}

simpleCache("target_DE_classlist_reference" %>% addversion, {
positives.celltypes=list(
  Ery=list(classvar=config$cell_type_variable, targets=c("Ery")),
  Bcell=list(classvar=config$cell_type_variable, targets=c("Bcell")),
  MEP=list(classvar=config$cell_type_variable, targets=c("MEP")),
  CMP=list(classvar=config$cell_type_variable, targets=c("CMP")),
  MPP=list(classvar=config$cell_type_variable, targets=c( "MPP")),
  CD34=list(classvar=config$cell_type_variable, targets=c( "CD34 Bone Marrow", "CD34 Coord")),
  HSC=list(classvar=config$cell_type_variable, targets=c("HSC")),
  GMP=list(classvar=config$cell_type_variable, targets=c("GMP")),
  LMPP=list(classvar=config$cell_type_variable, targets=c("LMPP")),
  CLP=list(classvar=config$cell_type_variable, targets=c("CLP")),
  CD8Tcell=list(classvar=config$cell_type_variable, targets=c("CD8Tcell")),
  CD4Tcell=list(classvar=config$cell_type_variable, targets=c("CD4Tcell")),
  Mono=list(classvar=config$cell_type_variable, targets=c("Mono")),
  NKcell=list(classvar=config$cell_type_variable, targets=c("NKcell"))
  )
}, assignToVar="positives.celltypes", reload=T)


ddsid=digest::digest(dds)

simpleCache(paste0("deseq2.celltypes.eachvsall_parallel_ddsid", ddsid)  %>% addversion, {
  
  dds.celltypes= dds[peak.set,refids]
par.deseq2.celltypes.eachvsall=parallel::mclapply(1:length(positives.celltypes), function(x, dd, allpos, pd){
  
  lab=names(allpos)[x]
  classvar=allpos[[x]]$classvar
  levs=c(lab, "Rest")
  is.target= function(x, targets) fifelse(x %in% targets, levs[1], levs[2])
  
  
simpleCache::simpleCache(paste0("deseq2_celltypes_target-",lab, "_vsrest_celltypesid", digest::digest(allpos),"_ddsid_",digest::digest(dd),  "analysis", analysis.version), {

dd[["target_vs_rest"]] <- factor(is.target(dd[[classvar]], allpos[[x]]$targets), levels=levs)

# Re-run the DESeq pipeline with the new condition
design(dd) <- ~target_vs_rest
dd <- DESeq(dd)  
res <- results(dd, contrast = c("target_vs_rest", levs[1], levs[2]))  

 }, assignToVar="res", reload=T)
  
  
  },allpos=positives.celltypes,dd=dds.celltypes, mc.cores=10, mc.cleanup=T)

}, assignToVar="par.deseq2.celltypes.eachvsall", reload=T)

################################################################################
#format results
################################################################################

lsst=par.deseq2.celltypes.eachvsall


simpleCache(paste0("deseq2.table.celltypes.unfiltered_ddsid", ddsid) %>% addversion, {
deseq2table.celltypes.unfiltered=lapply(1:length(lsst), function(x){
trgts=strsplit(lsst[[x]]@elementMetadata[3,2], split=" ")[[1]][c(4,6)]

tab=as.data.frame(lsst[[x]]) %>% dplyr::mutate(target=trgts[1], reference=trgts[2], contrast=paste0(trgts[1], "_vs_",trgts[2] )) %>% names2col(., "Geneid")

rownames(tab)=NULL
tab
  
}) %>% bind_rows()
}, assignToVar="deseq2table.celltypes.unfiltered", reload=T)


dump.table(deseq2table.celltypes.unfiltered)

simpleCache(paste0("deseq2table.celltypes.filtered_ddsid", ddsid) %>% addversion, {
deseq2table.celltypes.unfiltered=lapply(1:length(lsst), function(x){
trgts=strsplit(lsst[[x]]@elementMetadata[3,2], split=" ")[[1]][c(4,6)]

tab=as.data.frame(lsst[[x]]) %>% dplyr::mutate(target=trgts[1], reference=trgts[2], contrast=paste0(trgts[1], "_vs_",trgts[2] )) %>% names2col(., "Geneid")

rownames(tab)=NULL
tab
  
}) %>% bind_rows()

allps=deseq2table.celltypes.unfiltered$pvalue
allps3=deseq2table.celltypes.unfiltered$padj
deseq2table.celltypes.unfiltered$padj2=p.adjust(allps, method="BH")
deseq2table.celltypes.unfiltered$padj3=p.adjust(allps3, method="BH")
deseq2table.celltypes.filtered=deseq2table.celltypes.unfiltered %>% dplyr::filter(pvalue<=0.05, abs(log2FoldChange)>=1) %>% arrange(-log2FoldChange) 

}, assignToVar="deseq2table.celltypes.filtered", reload=T)

dump.table(deseq2table.celltypes.filtered)
################################################################################
#collect subgroups' relevant peaks
################################################################################
targetlist=positives.celltypes
deseq2.table=deseq2table.celltypes.filtered
simpleCache("remake_depeaks.celltypes.filtered" %>% addversion, {
all.peaks.celltypes.deseq2=lapply(1:length(targetlist), function(x){

  deseq2.table %>% dplyr::filter(target==names(targetlist)[x]) %>% pull(Geneid) %>% unique
    
  
}) %>% givename(., names(targetlist))
all.peaks.celltypes.deseq2
}, assignToVar="all.peaks.celltypes.deseq2", reload=T)

simpleCache(paste0("closest.genes.celltypes.deseq2_ddsid", digest::digest(dds)) %>% addversion, {
all.closest.genes.celltypes.deseq2=lapply(1:length(targetlist), function(x){

  deseq2.table %>% dplyr::filter(target==names(targetlist)[x]) %>% annotate.close.genes(.) %>% pull(closest.tss) %>% removenas %>% unique
    
  
}) %>% givename(., names(targetlist))

}, assignToVar="all.closest.genes.celltypes.deseq2", reload=T)


simpleCache(paste0("deseq2.celltypes.data_ddsid", digest::digest(dds)) %>% addversion, {
  
  list(deseq2table.celltypes.filtered=deseq2table.celltypes.filtered,
    deseq2table.celltypes.unfiltered=deseq2table.celltypes.unfiltered,
    all.peaks.celltypes.deseq2=all.peaks.celltypes.deseq2,
    all.closest.genes.celltypes.deseq2=all.closest.genes.celltypes.deseq2
    
    )
}, assignToVar="deseq2.celltypes.data", reload=T)

list2env(deseq2.celltypes.data, .GlobalEnv)

```


## 15. Finding cell type "high signal" DARs via AUC calculation

In other words, find peaks whose accessibility ranks specific cell types on top (or bottom)


1. collect selected peaks with high loadings in relevant PCs, and differentially accessible via DESeq2

```{r}

################################################################################
# collect aucs for all subclasses
################################################################################

all.relevant.pcs=names(allcurves)
simpleCache(paste_("selected_peak_df", max.peaks.pull, "peaks_",paste(names(allcurves), collapse="-"), "version") %>%  addversion , {

selected.peak.df=lapply(all.relevant.pcs, function(selected.pc){
allcurves[[selected.pc]]$curve %>% dplyr::select(1,2,3,4,!!sym(selected.pc)) %>% dplyr::mutate(seqnames=Chr,start=Start, end=End, abspc=abs(!!sym(selected.pc))) %>% arrange(-abspc) %>% dplyr::mutate(rank=1:n(), PC=selected.pc, PC.loading=!!sym(selected.pc)) %>% dplyr::select(Geneid,seqnames, start, end, abspc, rank, PC, PC.loading) %>% head(max.peaks.pull)

}) %>% Reduce(rbind, .)

selectedpeakids=selected.peak.df %>% pull(Geneid) 
uniquepeakids=!duplicated(selectedpeakids)
selected.peak.df=selected.peak.df %>% dplyr::mutate(uniquepeak=uniquepeakids) %>% filter(uniquepeak)
}, assignToVar="selected.peak.df", reload=T)
################################################################################
#split dataset into 100 small datasets to process in parallel
################################################################################
num.splits=100
splits=selected.peak.df %>% dplyr::mutate(index=1:n(), bin=cut(index,num.splits, labels=F)) %>% group_split(bin)
```

2. Perform calculation of the AUCs, making sure to precompute everything we need before. 

```{r}
mc.cores=10

peaks=c(lapply(allcurves, function(x) x$curve$Geneid ) %>% Reduce(c, .), all.peaks.celltypes.deseq2 %>% Reduce(c, .)) %>% unique
  
  
collective.aucs.celltypes=compute.aucs.workflow(package.vars(positives.celltypes, analysis.version, max.peaks.pull, peaks, norm.peak.vals, dataset.info, refids, meta, mc.cores  ))

pks=annotation.peaks %>% pull(Geneid)

annot.peaks.aucs=rcollective.aucs.celltypes %>% pivot_wider(., id_cols=c("Geneid"), names_from="target", values_from="auc") %>% as.data.frame %>% arrange(factor(Geneid, levels=pks)) %>% left_join(annotation.peaks, ., by="Geneid")

dump.table(annot.peaks.aucs)

```


3. Define high signal peaks

```{r}

high.signal.peaks.target= collective.aucs.celltypes %>% filter(target==!!config$target_cell_type, auc>= auc.thresh) 


high.signal.peaks.celltypes= lapply(selected.celltype.list, function(x){ 
  
  collective.aucs.celltypes %>% filter(target==!!x, auc>= auc.thresh) %>% pull(Geneid)
}) %>% givename(., selected.celltype.list)
  
  
```

3. Make the heatmap of the high signal peaks

```{r, fig.width=5, fig.height=5}

label="celltypes"

#retrieve peak values matrix for all  important peaks

simpleCache(paste_("remake_all.peaks.celltypes_peaks_screened_celltypes",gsub(" ", "-", paste(selected.celltype.list, collapse="-")), max.peaks.pull, "aucthresh", auc.thresh) %>% addversion, {
 
highs=lapply(selected.celltype.list, function(x) collective.aucs.celltypes %>% filter(auc>=auc.thresh, target== !!x) ) %>% bind_rows()  


high.peak.annot =highs %>% arrange(factor(target, levels=selected.celltype.list), -auc)  %>% dplyr::select(Geneid,target, auc)
high.peak.annot=high.peak.annot %>% dplyr::mutate(dup=duplicated(high.peak.annot$Geneid)) %>% filter(!dup) %>% as.data.frame %>%  col2names(., "Geneid")
high.peaks=high.peak.annot %>% pull(Geneid) %>% unique

all.peaks.celltypes.auc=lapply(selected.celltype.list, function(x) collective.aucs.celltypes %>% filter(auc>=auc.thresh, target== !!x) %>% pull(Geneid) ) %>% givename(., selected.celltype.list)


high.samples=lapply(highs %>% pull(target) %>% unique, function(x)  get.samples.from.class(x, positives.celltypes)) %>% Reduce(c, .)


high.matrix.numbers=get.sample.peakvals(peakid=high.peaks,samples=high.samples ) %>% giverownames(., high.samples)

high.matrix.numbers.t=high.matrix.numbers %>% t 
high.matrix.numbers.t=high.matrix.numbers.t[get.variant.rows(high.matrix.numbers.t), ]
hmpeaks=rownames(high.matrix.numbers.t)

celltype.peak.info.list=list(
  all.peaks.celltypes.auc=all.peaks.celltypes.auc,
  selected.celltype.list=selected.celltype.list,
  auc.thresh=auc.thresh, 
  highs=highs,
  high.peak.annot=high.peak.annot,
high.peaks=high.peaks,
  hmpeaks=hmpeaks,
  high.samples=high.samples,
  high.matrix.numbers=high.matrix.numbers,
  high.matrix.numbers.t=high.matrix.numbers.t
)
}, assignToVar="celltype.peak.info.list", reload=T)

list2env(celltype.peak.info.list, .GlobalEnv)



sca=1.5
tpdf(path=config$plotpath,paste_("pheatmap_highsignalpeaks", label, "auc", auc.thresh) %>% addversion, he=pw*sca*2, wi=pw*sca*1) 
print(ComplexHeatmap::pheatmap(high.matrix.numbers.t, annotation_col=pca.data[high.samples,] %>% dplyr::mutate(target=celltype) %>% dplyr::select( target),scale="row", annotation_row=high.peak.annot[hmpeaks, ] %>% dplyr::select(target), breaks=seq(-2,2, 0.1), show_colnames=F, show_rownames=F, cluster_col=F, cluster_row=F, annotation_colors=allcolors, use_raster=T ) )
dev.off()


```

# 16. Look at the same high cell type signal regions in the in vitro samples 


```{r, fig.width=5, fig.height=5}
## only treatments 

peaks=concordance.peaks$discordant
allcolors$optimal=c("TRUE"="firebrick", "FALSE"="white")

samples.temp= test.ids.list %>% Reduce(c, .)
sample.arrangement.mat= pca.data[samples.temp, ] %>% arrange(across(all_of( annotvars ))) 
sample.arrangement=sample.arrangement.mat %>% rownames %>% rev

all.matrix.numbers=get.sample.peakvals(peakid=peaks,samples=sample.arrangement) %>% giverownames(., sample.arrangement )

# annotations for the columns
annot.col.invitro=pca.data[sample.arrangement,] %>%  dplyr::mutate(optimal=rbc.combo=="5E" ) %>% dplyr::select( all_of(c(dataset.info$annotvars %>% removegene(., "rbc.round1"), "optimal")))



sca=1.5
hm.clustered=ComplexHeatmap::pheatmap(all.matrix.numbers %>% t, annotation_col=annot.col.invitro ,scale="row", annotation_row=high.peak.annot[hmpeaks, ] %>% dplyr::select(target), breaks=seq(-2,2, 0.1), show_colnames=F, show_rownames=F, cluster_col=T, cluster_row=F, annotation_colors=allcolors, use_raster=T)

tpdf(path=config$plotpath,paste_("pheatmap_highsignalpeaks_tests_cluster", label, "auc", auc.thresh) %>% addversion, he=pw*sca*2.26, wi=pw*sca*1.2) 
print(hm.clustered)
dev.off()

hm.unclustered=ComplexHeatmap::pheatmap(all.matrix.numbers[sample.arrangement,] %>% t, annotation_col=annot.col.invitro,scale="row", annotation_row=high.peak.annot[hmpeaks, ] %>% dplyr::select(target), breaks=seq(-2,2, 0.05), show_colnames=F, show_rownames=F, cluster_col=F, cluster_row=F, annotation_colors=allcolors, use_raster=T)
obj.unclustered=ComplexHeatmap::draw(hm.unclustered)
tpdf(path=config$plotpath,paste_("pheatmap_highsignalpeaks_tests_nocluster", label, "auc", auc.thresh) %>% addversion, he=pw*sca*2.26, wi=pw*sca*1.2) 
print(hm.unclustered)
dev.off()
```

# 17. quantifying intersect between differentially open regions and high signal regions
```{r}
library(ggbreak)
#high signal peaks
targetslist=deseq2table.celltypes.filtered %>% pull(target) %>% unique

dordf=lapply(targetslist, function(k){
  
hsp=collective.aucs.celltypes %>% filter(target==!!k, auc>=auc.thresh) %>% pull(Geneid)
diffs=deseq2table.celltypes.filtered %>% dplyr::filter(target==!!k, log2FoldChange>=1) %>% pull(Geneid)
c(celltype=k, high.signal=length(hsp), both=length(intersect(hsp,diffs)), only.dor=length(setdiff(diffs, hsp) ), only.high.signal=length(setdiff(hsp, diffs)))

}) %>% bind_rows() %>% as.data.frame %>% pivot_longer(., cols=c("both","only.dor","only.high.signal"), names_to="region.class", values_to="number")

nlevs=dordf %>% group_by(celltype) %>% summarise(total=sum(as.numeric(number))) %>% arrange(-total) %>% pull(celltype)

darsplot=ggplot(dordf, aes(x=factor(celltype, levels=nlevs),y=as.numeric(number),  fill=factor(region.class, levels=c("only.dor","both","only.high.signal") %>% rev)))+
  geom_col(color="black", size=.2)+
  theme_classic()+
  theme()+
  scale_fill_manual(values=c(both="gold", only.high.signal="aquamarine3", only.dor="violet"), name="region class")+
    scale_y_break(c(30000, 70000))+theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = .5))
  
################################################################################
#  plot only cell identity regions
################################################################################

rc=collective.aucs.celltypes %>% dplyr::filter(auc>= 0.95) %>% groupcount(., grp = "target")
levsauc=rc %>% arrange(-counts) %>% pull(target)
ciplot=ggplot(rc, aes(x=factor(target, levels=levsauc),y=counts))+
  geom_col(color="black", size=.2, fill="gold")+
  theme_classic()+
theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = .5))  

sca=1.5
tpdf(path=config$plotpath, "barplot_aucs_celltypes", wi=pw*sca, he=pw*sca*.8)
print(ciplot)

dev.off()

sca=1.5
tpdf(path=config$plotpath, "barplot_DARS_hs_celltypes", wi=pw*sca, he=pw*sca*.6)
print(darsplot)

dev.off()

dordf=dordf %>% as.data.frame

dump.table(dordf)
```


# 19. make a gene set enrichment heatmap for the closest tss of the cell type peaks

```{r, fig.width=5, fig.height=5}
genesigs=gsetpars[1:3]

he.celltypes=get.hyper.enrichments(all.peaks.celltypes.auc[!isempty.list(all.peaks.celltypes.auc)] %>% annotate.close.genes(.) %>% lapply(., function(x) x$closest.tss %>% unique), colorlist=allcolors$target[selected.celltype.list], gsetpars=genesigs)
typp="auc"

maxtop=5

lapply(names(genesigs), function(selgs){
levs= selected.celltype.list

gseadf=he.celltypes$df %>% filter(geneset==selgs) %>% group_split(clusterlabel) %>% lapply(., function(x) x %>% arrange(-jaccard_index) %>% head(maxtop)) %>% Reduce(rbind,.)

if(!is.null(gseadf)){
a=
  ggplot(gseadf, aes(x=cluster,  y=jaccard_index, alpha= ifelse(pval<=0.05, 1,0), fill=factor(clusterlabel, levels=levs)) )+geom_col()+geom_text(inherit.aes=F, aes(label=short.label, x=cluster,hjust=0, y=0 ))+rotatex(90)+scale_fill_manual(values=allcolors$target[levs])+facet_grid(rows=vars(factor(clusterlabel, levels=levs)), scales="free_y")+coord_flip()+theme_minimal()+scale_x_reverse()+NoLegend()

sca=1.5
tpdf(path=config$plotpath, paste_("barplot_gsea_closest_genes_", typp, selgs, "auc", auc.thresh) %>% addversion, wi=pw*sca*.5, he=pw*sca*1.95)
print(a)
dev.off()
}

})

```

# 20. calculating signature score with the peaks

```{r, fig.width=8, fig.height=5}
selecttop=NULL
sz=3
typp="auc"

###
# include specific celltypes and shapes into the module score biplots
###
shapes=c(HSC=4, Ery=21, CMP=22,Bcell=7, MEP=23, "Round1"=24, "Round2"=25)

if(typp=="deseq2"){

 celltype.peaklist=all.peaks.celltypes.deseq2

}else{
 if(typp=="auc"){
  all.peaks.celltypes.auc=lapply(selected.celltype.list, function(x) collective.aucs.celltypes %>% filter(auc>=auc.thresh, target== !!x) %>% pull(Geneid) ) %>% givename(., selected.celltype.list) 
  celltype.peaklist=all.peaks.celltypes.auc
 }
  
}

if(!is.null(selecttop)){
celltype.peaklist=adjust.markerlist(celltype.peaklist, 100)
}

simpleCache("peak_signature_calculations_celltypes" %>% paste_(., ifelse(!is.null(selecttop), paste("selecttop_", selecttop), ""), typp, ifelse(typp=="auc", auc.thresh, ""), "classes", digest::digest(selected.celltype.list)) %>% addversion, {
gsva_output=gsva(vsd,
                         gset.idx.list=celltype.peaklist,
                         method = "ssgsea")
signature.scores=gsva_output %>% t 

}, assignToVar="signature.scores.celltypes", reload=T)

sigs=signature.scores.celltypes %>% colnames


###
#subtract the average hsc score and divide by the average score of the actual celltype
###


scale.to.trgt.avg=function(ctp, matt){
  ctp.samples= pca.data %>% dplyr::filter(celltype==!!ctp) %>% pull(Experiment)
  mn=matt[ctp.samples, ctp] %>% mean(., na.rm=T)
  matt[, ctp]= matt[,ctp]/mn
  matt[,ctp]
}


subtract.ref.avg=function(ctp, matt, zeroref){
  refsamples= pca.data %>% dplyr::filter(celltype==!!zeroref) %>% pull(Experiment)
  mn=matt[refsamples, ctp] %>% mean(., na.rm=T)
  matt[, ctp]=matt[,ctp]-mn
matt
  }

normalise.signatures= function(matt, zeroref){

matt2=matt
for(ctp in colnames(matt)){
                      
  matt2[, ctp]=  scale.to.trgt.avg(ctp, subtract.ref.avg(ctp, matt,zeroref))
  
  
}
colnames(matt2)=colnames(matt)
matt2}

signature.scores.celltypes.relative=normalise.signatures(signature.scores.celltypes, zeroref="HSC")    

### make all negative scores zero

signature.scores.celltypes.processed=apply(signature.scores.celltypes.relative, c(1,2), function(x) ifelse(x<0, 0, x)) 


dump.table(signature.scores.celltypes)
dump.table(signature.scores.celltypes.processed)

```

# 21. plot signatures

```{r, fig.width=8, fig.height=5}


x_values <- list(
  signature.scores.celltypes,
  signature.scores.celltypes.processed
)

signature.vars=c()
# Loop over the different values of x
for (selected.signatures in x_values) {
  for (mv in sigs) {
    # Determine a suffix based on the current selected.signatures
     if (identical(selected.signatures, signature.scores.celltypes)) {
      suffix= ""
      selected.signatures=signature.scores.celltypes
    } else {
      suffix="processed_"
      selected.signatures=signature.scores.celltypes.processed
      
    }
    
    #signature.vars=selected.signatures %>% colnames %>% paste_("signature.score_", suffix,.)
    # Create the column name dynamically
    col_name <- paste0("signature.score_", suffix, mv)
    signature.vars<-c(signature.vars, col_name)
    # Assign values to the pca.data
    pca.data[, col_name] <- selected.signatures[pca.data %>% pull(Experiment), mv] %>% unname()
  }



sig.combs=combn(signature.vars, 2) %>% t


for(varr in c(
  "insulin.heparin.2", "hydrocortisone.1", "hydrocortisone.2", "insulin.heparin.1", "epo.1", "epo.2", 
  "il4.1", "il4.2", "tgfbeta.1", "tgfbeta.2")){
for(j in 1:nrow(sig.combs)){
  tpdf(path=config$plotpath, paste_("pointplot_signatures", sig.combs[j, 1], sig.combs[j, 2], "colorby_", varr, "auc", auc.thresh) %>% addversion, he=pw*sca, wi=pw*sca)
print(ggplot(pca.data, aes(x=!!sym(sig.combs[j, 1]), y=!!sym(sig.combs[j,2]), fill=factor(!!sym(varr)), shape=celltype, color=factor(!!sym(varr))))+
  geom_point(size=sz, alpha=0.7)+
  cowplot::theme_cowplot()+
    scale_fill_manual(values=getcolors(pca.data, varr))+
    scale_color_manual(values=getcolors(pca.data,varr))+
    scale_shape_manual(values=shapes)+
  rotatex(90)+
    theme(legend.position="bottom"))
dev.off()
}
}


## normalise signature

sca=1.5
sz=.5
varrs=sig.combs %>% as.vector %>% unique
for(v in varrs){
  mndata=pca.data %>% group_by(celltype) %>% summarise(mn=mean(!!sym(v)), std=sd(!!sym(v)))
  
tpdf(path=config$plotpath, paste_("bharplot_relative_signature_score", v), wi=pw*sca, he=pw*sca)  
  
print(ggplot(mndata, aes(x=factor(celltype,levels=names(allcolors$celltype) ), y=mn, fill=factor(celltype,levels=names(allcolors$celltype) )))+geom_col()+
    geom_jitter(data=pca.data, inherit.aes=F, aes(x=factor(celltype,levels=names(allcolors$celltype) ), y=!!sym(v)),alpha=0.3, width = .2, size=sz)+
    geom_errorbar(data=mndata, aes(ymax=mn+std, ymin=mn-std), width=0.6, color="#888888")+
    scale_fill_manual(values=allcolors$celltype)+ggtitle(paste_(v, "relative to HSC"))+theme_classic()+theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = .5))+NoLegend() )

  dev.off()
  
}




}

dump.table(pca.data)


####
# calculate pca and umap of the signatures
####
library(uwot)
removecol=function(x, coll) x %>% dplyr::select(-!!sym(coll))

sig.umap.results=umap(signature.scores.celltypes.processed %>% as.data.frame %>% removecol(., "HSC"), init = "random",  min_dist =2.5,n_neighbors = 6, repulsion_strength=3, ret_model=T)


sig.umap.df= sig.umap.results$embedding %>% givecolnames(., ind=c(1,2), nms=c("UMAP1", "UMAP2")) %>% cbind(.,pca.data[rownames(sig.umap.results$embedding), ]) 

colvar="celltype"
ggplot(sig.umap.df, aes(x=UMAP1, y=UMAP2, col=factor(!!sym(colvar))))+geom_point()+scale_color_manual(values=allcolors[[colvar]])

```


22. facs plot round 1 

```{r}

reagentplot=ggplot(meta %>% filter(dsname %in% test.datasets) %>% pivot_longer(cols=c("epo.1", "insulin.heparin.1", "hydrocortisone.1"), names_to="reagent", values_to="amount") %>% filter(amount>0) , aes(x=factor(condition), y=factor(reagent), size=amount))+
  geom_point()+
  scale_size_continuous(range = c(1, 3)) +
  theme_classic()+
   xlab("Condition")+
 ylab("Reagent")


sz1=3
facsdata=read.csv("~/metadata/Day 7 RBC diff. _final.csv", header=T, skip=3) %>% fixnames %>% as.data.frame


ggplot(facsdata %>% dplyr::mutate(rbc.round1=factor(Condition)), aes(x=CD36.CD71..subset.Median.CD36, y=CD36.CD71.subset.Median.CD71))+geom_point(aes(color=rbc.round1))+scale_color_manual(values=allcolors$rbc.round1)


ggplot(facsdata %>% dplyr::mutate(rbc.round1=factor(Condition), rtio=CD36.CD71.subset.Median.CD71/CD36.CD71..subset.Median.CD36), aes(x=Condition, y=CD36.CD71.subset.Freq.of.Parent))+geom_jitter(aes( size=rtio), width=.1)

facsdataround1=facsdata %>% dplyr::mutate(rbc.round1=Condition, rtio=CD36.CD71.subset.Median.CD71/CD36.CD71..subset.Median.CD36, pop.ratio=CD36.CD71.subset.Freq.of.Parent/CD71.subset.Freq.of.Parent)

dump.table(facsdataround1)

ggplot(facsdataround1, aes(y=rtio, x=CD36.CD71.subset.Freq.of.Parent, color=factor(rbc.round1)))+geom_point(aes(size=pop.ratio))+scale_color_manual(values=allcolors$rbc.round1)


sca=1.3
rr=600

layout=
"AAAAAA
AAAAAA
AAAAAA
BBBBBB"

fd=facsdata %>% group_by(Condition) %>% summarise(mn=mean(CD36.CD71.subset.Freq.of.Parent), sdev=sd(CD36.CD71.subset.Freq.of.Parent), minn=min(CD36.CD71.subset.Freq.of.Parent), ymax=max(CD36.CD71.subset.Freq.of.Parent), CD36.CD71.subset.Freq.of.Parent=minn)

facsplot=ggplot(facsdataround1, aes(x=factor(Condition), y=CD36.CD71.subset.Freq.of.Parent))+
  geom_point(aes(fill=factor(Condition)), shape=24, color="black", size=sz1)+
  geom_segment(data=fd, aes(xend=factor(Condition), yend=ymax), color="black")+
  scale_fill_manual(values=allcolors$rbc.round1)+
  cowplot::theme_cowplot()+
  cowplot::background_grid()+
  ylab("% CD36+ CD71+ cells")+
  xlab("EDM1 Treatment")

pan=wrap_plots(A =facsplot , B = reagentplot,
                   design = layout)
tpdf(path=config$plotpath, paste0("fig2_triangleplot_facs_EDM1_vs_percentcd36cd71_analysisversion_", analysis.version), he=pw*sca, wi=pw*sca*1.5)
print(pan)
dev.off()



```



# 22. round 1 distances to centroid
```{r fig.height=4, fig.width=6}

pca.data=all.dists[[1]][[2]]
sz1=2.5
shapes=c("1"=0, "2"=1, "3"=2, "4"=5, "5"=6, "6"=4, "7"=7, "8"=8)
reagentplot=ggplot(pca.data %>% filter(dsname %in% test.datasets, tmnt2=="nt") %>% pivot_longer(cols=c("epo.1", "insulin.heparin.1", "hydrocortisone.1"), names_to="reagent", values_to="amount") %>% filter(amount>0) , aes(x=factor(rbc.round1), y=factor(reagent), size=amount))+
  geom_point()+
  scale_size_continuous(range = c(1, 3)) +
  theme_classic()+
   xlab("Condition")+
 ylab("Reagent")


test.datasets=c("Seruggia2024-1", "Seruggia2024-2")
dist.summary=pca.data %>% dplyr::filter(dsname %in% test.datasets, tmnt2=="nt") %>% group_by( rbc.round1, epo.1, insulin.heparin.1, hydrocortisone.1,  epo.2, insulin.heparin.2, hydrocortisone.2 ) %>% summarise(mn=mean(dist.to.centroid.pca), std=sd(dist.to.centroid.pca))

pcaplot8=(ggplot(dist.summary, aes(x=rbc.round1, y=mn, ymin=mn-std, ymax=mn+std, fill=factor(rbc.round1)), shape=factor(rbc.round1))+
    #geom_col()+
    #geom_errorbar(width=0.6)+
geom_point(data=pca.data %>% dplyr::filter(dsname %in% test.datasets, tmnt2=="nt"),inherit.aes=F, aes(y=dist.to.centroid.pca, x=rbc.round1, fill=factor(rbc.round1)), shape=22, color="black", size=sz1)+
   scale_fill_manual(values=allcolors$rbc.round1)+
    scale_shape_manual(values=shapes)+
     #coord_cartesian(ylim=c(400, 500))+
    xlab("" )+
   ylab(paste("PCA distance to",  dataset.info$target_cell_type, "centroid"))+
     cowplot::theme_cowplot()+ cowplot::background_grid() )#%>% divide_legend_columns(., 2)


reglevs=c("epo.1", "insulin.heparin.1", "hydrocortisone.1")
reagentplot64=ggplot(dist.summary %>% pivot_longer(cols=all_of(reglevs), names_to="reagent", values_to="amount") %>% filter(amount>0) , aes(x=factor(rbc.round1), y=factor(reagent,levels=reglevs ), size=amount))+
  geom_point()+
  scale_size_continuous(range = c(1, 3)) +
  theme_minimal()+
   xlab("Condition")+
 ylab("Reagent")


layout=c(
"AAAAAA
AAAAAA
AAAAAA
CCCCCC")

pan8=wrap_plots(A=pcaplot8, C=reagentplot, design=layout)

sca=1.3
rr=600

tpdf(path=config$plotpath, paste0("pointplot_pca_distance_to_target_edm1_analysisversion", analysis.version), he=pw*sca, wi=pw*sca*1.5)
print(pan8)
dev.off()



```

# 23. FACS round 2 plots

```{r fig.width=4, fig.height=4}
sz=2
facsdata.2=(fread("~/metadata/FACS_EDM2_rep1_rep2_ready.csv", header=T, check.names=T) %>% as.data.frame())
facs2ids=lapply(facsdata.2[, "V1"], function(x) strsplit(x, split="_")[[1]][3])
facsdata.2=facsdata.2 %>% dplyr::mutate(rbc.combo=facs2ids,rbc.combo=paste0(substr(rbc.combo, 2,2),substr(rbc.combo, 1,1)), rbc.round2=substr(rbc.combo, 2,2), rbc.round1=substr(rbc.combo, 1,1), rbc.combo.rev=paste0(rbc.round2,rbc.round1), ratio.cd71.to.cd36=cd36.cd71.Median.cd71/cd36.cd71.median.cd36, ratio.cells.double.to.cd71=cd36.cd71.freq.of.parent/cd71..freq.of.parent)

dump.table(facsdata.2)


facs2plot.bars=ggplot(facsdata.2 %>% dplyr::mutate(top=100), aes(x=rbc.round2 ))+
  geom_col(aes(y=top), fill="pink")+
  geom_col(aes(y=cd36.cd71.freq.of.parent), fill="red")+
  scale_fill_manual(values=allcolors$rbc.round1)+
  facet_wrap(~rbc.round1, nrow=1, scales="free_x")+
  cowplot::theme_cowplot()+ cowplot::background_grid()

fd2= facsdata.2 %>% group_by(rbc.combo, rbc.round1, rbc.round2) %>% summarise(ymin=min(cd36.cd71.freq.of.parent), ymax=max(cd36.cd71.freq.of.parent), cd36.cd71.freq.of.parent=ymin)



facs2plot.points=ggplot(facsdata.2 %>% dplyr::mutate(top=100), aes(x=rbc.round2 ))+
  geom_point(aes(fill=factor(rbc.round1), y=cd36.cd71.freq.of.parent, color=factor(rbc.round1)), shape=24, size=sz)+
  geom_segment(data=fd2, aes(y=ymin, yend=ymax, x=rbc.round2, xend=rbc.round2), color="black")+
  scale_fill_manual(values=allcolors$rbc.round1)+
   scale_color_manual(values=allcolors$rbc.round1)+
  facet_wrap(~rbc.round1, nrow=1, scales="free_x")+
  cowplot::theme_cowplot()+ cowplot::background_grid()


facs2plot.points.7136=ggplot(facsdata.2 %>% dplyr::mutate(top=100), aes(x=rbc.round2 ))+
  geom_point(aes(y=cd36.cd71.freq.of.parent, size=ratio.cd71.to.cd36), fill="grey", color="black", shape=24)+
  geom_segment(data=fd2, aes(y=ymin, yend=ymax, x=rbc.round2, xend=rbc.round2), color="black")+
  facet_wrap(~rbc.round1, nrow=1, scales="free_x")+
  cowplot::theme_cowplot()+ cowplot::background_grid()

facs2plot.points.7136.color=ggplot(facsdata.2 %>% dplyr::mutate(top=100), aes(x=rbc.round2 ))+
  geom_point(aes(y=cd36.cd71.freq.of.parent, fill=ratio.cd71.to.cd36), color="black", size=sz, shape=24)+
  geom_segment(data=fd2, aes(y=ymin, yend=ymax, x=rbc.round2, xend=rbc.round2), color="black")+
  scale_fill_viridis(option="A")+
  scale_color_viridis(option="A")+
  facet_wrap(~rbc.round1, nrow=1, scales="free_x")+
  cowplot::theme_cowplot()+ cowplot::background_grid()

facs2plot.71=ggplot(facsdata.2, shape=22, aes(x=rbc.round2, y=1, size=cd36.cd71.Median.cd71), color="black")+
  geom_point()+
  scale_color_manual(values=allcolors$rbc.round1)+
  facet_wrap(~rbc.round1, nrow=1, scales="free_x")+
  cowplot::theme_cowplot()

facs2plot.36=ggplot(facsdata.2,shape=22, aes(x=rbc.round2, y=1, size=cd36.cd71.median.cd36), color="black")+
  geom_point()+
  scale_color_manual(values=allcolors$rbc.round1)+
  facet_wrap(~rbc.round1, nrow=1, scales="free_x")+
  theme_minimal()

facs2bars=ggplot(facsdata.2, aes(x=rbc.round1, y=cd36.cd71.freq.of.parent, fill=rbc.round1))+
  geom_col()+
  scale_fill_manual(values=allcolors$rbc.round1)+
  facet_wrap(~rbc.round2, nrow=1, scales="free_x")+
  theme_minimal()


ggplot(facsdata.2, aes(x=log10(cd36.Median), size=cd36.cd71.freq.of.parent, y=log10(cd71.median), color=rbc.round1))+
  geom_point()+
  scale_color_manual(values=allcolors$rbc.round1)+theme_minimal()

######################

shps=c("A"=5, "B"=6, "C"=7, "D"=8, "E"=21, "F"=22, "G"=23, "H"=24)
ggplot(facsdata.2 %>% dplyr::mutate( ratio.cd71.to.cd36=cd36.cd71.Median.cd71/cd36.cd71.median.cd36, ratio.cells.double.to.cd71=cd36.cd71.freq.of.parent/cd71..freq.of.parent), aes(y=rtio, x=cd36.cd71.freq.of.parent, color=factor(rbc.round1)))+geom_point(aes(size=pop.ratio, shape=rbc.round2))+scale_color_manual(values=allcolors$rbc.round1)+scale_shape_manual(values=shps)
```

# 24 round 2 distance to centroid
```{r fig.height=4, fig.width=8}

reglevs2=c("epo.2", "hydrocortisone.2", "insulin.heparin.2", "epo.1", "hydrocortisone.1", "insulin.heparin.1")
reglevs=c("epo.1", "epo.2","insulin.heparin.1", "insulin.heparin.2","hydrocortisone.1", "hydrocortisone.2")
reglevs3=c("epo.2", "hydrocortisone.2", "insulin.heparin.2","epo.1", "hydrocortisone.1", "insulin.heparin.1")

library("ggbeeswarm")
shapes=c("1"=0, "2"=1, "3"=2, "4"=5, "5"=6, "6"=4, "7"=7, "8"=8)

ylimit.up=550
ylimit.down=300

pca.data=pca.data %>% dplyr::mutate(rbc.combo.edm2.edm1=paste0(rbc.round2, rbc.round1))
test.datasets=c("Seruggia2024-2")
dist.summary=pca.data %>% dplyr::filter(dsname %in% test.datasets, tmnt2!="nt") %>% group_by(rbc.combo,rbc.combo.edm2.edm1, rbc.round1,rbc.round2, epo.1, insulin.heparin.1, hydrocortisone.1,  epo.2, insulin.heparin.2, hydrocortisone.2) %>% summarise(mn=mean(dist.to.centroid.pca, na.rm=T), sttd=sd(dist.to.centroid.pca, na.rm=T)) %>% dplyr::mutate(lower=mn-sttd, upper=mn+sttd)




pctmedian = function(vec, pctile=.25){
 ec=quantile(vec, pctile)[1]
 median(vec[vec<=ec], na.rm=T)
}

pctmean = function(vec, pctile=.25){
 ec=quantile(vec, pctile)[1]
 mean(vec[vec<=ec], na.rm=T)
}

pca.data.summary=pca.data %>% filter(Experiment %in% testids) %>% group_by(rbc.round1) %>% summarise(median=median(dist.to.centroid.pca), median25=pctmedian(dist.to.centroid.pca, .25),median10=pctmedian(dist.to.centroid.pca, .1), group.mean=mean(dist.to.centroid.pca),group.sd=sd(dist.to.centroid.pca), mean25=pctmean(dist.to.centroid.pca, .25), mean10=pctmean(dist.to.centroid.pca, .10), mean5=pctmean(dist.to.centroid.pca, .05), group.lowest=min(dist.to.centroid.pca)   )

# for a vector, calculate the median of a specific pecentile


pcaplot64=(ggplot(pca.data  %>% dplyr::filter(dsname %in% test.datasets, tmnt2!="nt"), aes(x=rbc.round2, y=(dist.to.centroid.pca), fill=factor(insulin.heparin.2), color=factor(insulin.heparin.2)))+
          geom_point( size=3, shape=22)+
    facet_wrap(~rbc.round1, nrow=1, scales="free_x")+
     ylim(c(ylimit.down, ylimit.up+50))+
    xlab("" )+
   ylab(paste("PCA distance to",  config$target_cell_type, "centroid"))+
      cowplot::theme_cowplot()+cowplot::background_grid()+
     theme(axis.text.x = element_text(vjust = 0.5)))



pcaplot64.nocolor=(ggplot(pca.data  %>% dplyr::filter(dsname %in% test.datasets, tmnt2!="nt"), aes(x=rbc.round2, y=(dist.to.centroid.pca)))+
          geom_point( size=3, shape=22, fill="#AAAAAA")+
    facet_wrap(~rbc.round1, nrow=1, scales="free_x")+
            geom_hline(data=pca.data.summary, aes(yintercept=group.mean), linetype="dashed")+
    geom_hline(data=pca.data.summary, aes(yintercept=mean10), linetype="dashed", color="blue")+
    geom_hline(data=pca.data.summary, aes(yintercept=mean5), linetype="dashed", color="red")+
     ylim(c(ylimit.down, ylimit.up+50))+
    xlab("" )+
   ylab(paste("PCA distance to",  config$target_cell_type, "centroid"))+
      cowplot::theme_cowplot()+cowplot::background_grid()+
     theme(axis.text.x = element_text(vjust = 0.5))) 


pcaplot64.2=(ggplot(pca.data  %>% dplyr::filter(dsname %in% test.datasets, tmnt2!="NANANA"), aes(x=rbc.round1, y=ifelse(dist.to.centroid.pca<=ylimit.up,dist.to.centroid.pca,ylimit.up+50 ), fill=factor(rbc.round1), color=factor(rbc.round1)))+
          geom_point( size=3, shape=22)+
   scale_color_manual(values=allcolors$rbc.round1)+
     ylim(c(ylimit.down, ylimit.up+50))+
    xlab("" )+
   ylab(paste("PCA distance to",  config$target_cell_type, "centroid"))+
     facet_wrap(~rbc.round2, nrow=1, scales="free_x")+
     theme_minimal()+
     theme(axis.text.x = element_text(vjust = 0.5)))
  

reagentplot64=ggplot(dist.summary %>% pivot_longer(cols=all_of(reglevs3), names_to="reagent", values_to="amount") %>% filter(amount>0) , aes(x=factor(rbc.round2), y=factor(reagent,levels=reglevs3 ), size=amount))+
  facet_wrap(~rbc.round1, nrow=1, scales="free_x")+
  geom_point()+
  scale_size_continuous(range = c(1, 3)) +
  theme_minimal()+
   xlab("Condition")+
 ylab("Reagent")#+



reagentplot64.2=ggplot(dist.summary %>% pivot_longer(cols=all_of(reglevs2), names_to="reagent", values_to="amount") %>% filter(amount>0) , aes(x=factor(rbc.combo.edm2.edm1), y=factor(reagent,levels=rev(reglevs) ), size=amount))+
  geom_point()+
  scale_size_continuous(range = c(1, 3)) +
  theme_minimal()+
   xlab("Condition")+
 ylab("Reagent")


layout=c(
"
BBBBBB
AAAAAA
CCCCCC
CCCCCC")

pan64=wrap_plots(C=pcaplot64.nocolor, A=facs2plot.points.7136.color, B=reagentplot64, design=layout)
pan64.2=wrap_plots(A=pcaplot64.2,B=facs2bars, C=reagentplot64.2, design=layout)

sca=1.3


tpdf(path=config$plotpath, paste0("pointplot_pca_distance_to_target_edm1_perEDM1_analysisversion", analysis.version), he=pw*sca*1.8, wi=pw*sca*4)
print(pan64)
dev.off()


tpdf(path=config$plotpath, paste0("pointplot_pca_distance_to_target_edm1_perEDM2_analysisversion", analysis.version, "newdist"), he=pw*sca*1.8, wi=pw*sca*4)
print(pan64.2)
dev.off()


rd=pca.data %>% dplyr::filter(dsname %in% test.datasets) %>% dplyr::mutate(round=ifelse(tmnt2=="NANANA", "round1", "round2")) %>% group_by( round) %>% summarise(mn=median(dist.to.centroid.pca), std=sd(dist.to.centroid.pca))

ggplot(pca.data %>% dplyr::filter(dsname %in% test.datasets) %>% dplyr::mutate(round=ifelse(tmnt2=="NANANA", "round1", "round2") , eposum=epo.1+epo.2, hydrosum=hydrocortisone.1+hydrocortisone.2, ihsum=insulin.heparin.1+insulin.heparin.2) %>% dplyr::filter(tmnt1==tmnt2))+geom_boxplot(aes(fill=factor(hydrosum), y=dist.to.centroid.pca, x=factor(tmnt2) ), draw_quantiles=c(.25, .50, .75))+coord_cartesian(ylim=c(200, 1000))



tmnts=c("insulin.heparin.1","insulin.heparin.2", "hydrocortisone.1", "hydrocortisone.2", "epo.1", "epo.2")


pcaplots.alltogether=lapply(tmnts, function(fillvar){
  fcat(fillvar)
  colorvar=fillvar
  ds=pca.data  %>% dplyr::filter(dsname %in% test.datasets, tmnt2!="NANANA")
  vals=ds %>% pull(!!sym(fillvar)) %>% unique  %>% removenas
  fcat("vals", vals %>% paste(., collapse="-"))
plt=ggplot(ds, aes( x=factor(!!sym(fillvar)),y=dist.to.centroid.pca, color=factor(!!sym(colorvar)), fill=factor(!!sym(colorvar))))+
          geom_beeswarm( cex=2.5)+
          geom_boxplot(fill=NA)+
  geom_signif(comparisons=list(as.character(vals)), map_signif_level=T, na.rm=T)+
   scale_color_manual(values=allcolors[[colorvar]])+
  scale_fill_manual(values=allcolors[[colorvar]])+
     ylim(c(ylimit.down, ylimit.up+150))+
    xlab("" )+
   ylab(paste("PCA distance to",  config$target_cell_type, "centroid"))+
     theme_minimal()+
     theme(axis.text.x = element_text(vjust = 0.5))+
  ggtitle(fillvar)+
  NoLegend()
plt
}) %>% Reduce('+', .)

pcaplots.alltogether


sca=2.5
tpdf(path=config$plotpath, "boxplot_treatment_effects_together_signif", wi=pw*sca, he=pw*sca)
print(pcaplots.alltogether)
dev.off()

################################################################################
# conditioning one variable
################################################################################

tmnts=c("insulin.heparin.1","insulin.heparin.2", "hydrocortisone.2", "epo.1", "epo.2")

pcaplots.conditioned=lapply(tmnts, function(fillvar){

  vals=pca.data %>% pull(!!sym(fillvar)) %>% unique  %>% removenas
xvar="eih"
colorvar="epo.1"
condplots=lapply(vals, function(givenval){
    dtf=pca.data  %>% dplyr::filter(dsname %in% test.datasets, tmnt2!="NANANA", !!sym(fillvar)==!!givenval)

plt=ggplot(dtf, aes( x=factor(!!sym(xvar)),y=dist.to.centroid.pca, color=factor(!!sym(colorvar)), fill=factor(!!sym(colorvar))))+
          geom_beeswarm( cex=4)+
          geom_boxplot(fill=NA, outlier.shape=NA)+
   scale_color_manual(values=allcolors[[colorvar]])+
  scale_fill_manual(values=allcolors[[colorvar]])+
     ylim(c(ylimit.down, ylimit.up+100))+
    xlab("" )+
   ylab(paste("PCA distance to",  config$target_cell_type, "centroid"))+
     theme_minimal()+
     theme(axis.text.x = element_text(vjust = 0.5))+
   ggtitle(paste0("PCAdist|", fillvar, "=", givenval))+
  rotatex(90)+
  NoLegend()

plt

})

sca=1.5
tpdf(path=config$plotpath, paste0( "boxplot_treatment_effects_conditioned_on_",fillvar , "by",colorvar), wi=pw*sca*2, he=pw*sca)
print(condplots %>% Reduce('+', .))
dev.off()

}) 

pcaplots.conditioned

################################################################################
# wilcoxon tests among subgroups. 
################################################################################

#anova is aov
filtervarr="insulin.heparin.2"
filterval=0

filtervarr2="hydrocortisone.1"
filterval2=c(0,1)

filtervarr3="epo.1"
filterval3=c(3)
testvarr="hydrocortisone.2"


res=pca.data %>% dplyr::filter(dsname %in% test.datasets, tmnt2!="NANANA", !!sym(filtervarr) %in% filterval, !!sym(filtervarr2) %in% filterval2, !!sym(filtervarr3) %in% filterval3) %>%
  summarize(
    wilcox_p_value = wilcox.test(dist.to.centroid.pca ~ !!sym(testvarr))$p.value
  )

report <- sprintf(
  "filtering on: %s = %d, %s = %d, %s = %d, and test differences on groups of %s. Wilcoxon test p value= %f",
  filtervarr, filterval, filtervarr2, filterval2, filtervarr3, filterval3, testvarr, res$wilcox_p_value
)
fcat(report)


################################################################################
# kruskal wallis test among subgroups. 
################################################################################

#anova is aov
filtervarr="insulin.heparin.2"
filterval=0

filtervarr2="hydrocortisone.2"
filterval2=c(0,1)

filtervarr3="epo.1"
filterval3=c(3)
testvarr="hydrocortisone.1"


res=pca.data %>% dplyr::filter(dsname %in% test.datasets, tmnt2!="NANANA", !!sym(filtervarr) %in% filterval, !!sym(filtervarr2) %in% filterval2, !!sym(filtervarr3) %in% filterval3) %>%
  summarize(
    kruskal_p_value = kruskal.test(dist.to.centroid.pca ~ !!sym(testvarr))$p.value
  )

report <- sprintf(
  "filtering on: %s = %d, %s = %d, %s = %d, and test differences on groups of %s. Wilcoxon test p value= %f",
  filtervarr, filterval, filtervarr2, filterval2, filtervarr3, filterval3, testvarr, res$kruskal_p_value
)
fcat(report)

tmnts.c=c( "insulin.heparin.1", "hydrocortisone.1", "hydrocortisone.2" )
tmnts.v=c( "insulin.heparin.1", "hydrocortisone.1", "hydrocortisone.2" )
pcaplots.conditional=lapply(tmnts., function(fillvar){
  
vals=pca.data %>% pull(!!sym(fillvar)) %>% unique  
lapply(vals, function(givenval){
plt=ggplot(pca.data  %>% dplyr::filter(dsname %in% test.datasets, tmnt2!="NANANA", !!sym(fillvar)==!!givenval), aes( x=!!sym(fillvar),y=dist.to.centroid.pca, color=factor(!!sym(fillvar)), fill=factor(!!sym(fillvar))))+
          geom_beeswarm( cex=1)+
          geom_boxplot(fill=NA)+
     ylim(c(ylimit.down, ylimit.up+50))+
    xlab("" )+
   ylab(paste("PCA distance to",  config$target_cell_type, "centroid"))+
     theme_minimal()+
     theme(axis.text.x = element_text(vjust = 0.5))+
  ggtitle(paste0("PCAdistance|", fillvar, "=", givenval))#+
plt
})

}) %>% Reduce('+', .)

pcaplots.conditional



```



# 23 calculating a UMAP to compress all PCA's at once

```{r, fig.width=3, fig.height=4}

colorlist=allcolors

umap.pars=list(
  one=list(seed=42, md=0.01, nn=30,rs=.3),
  two=list(seed=42, md=0.01, nn=10, rs=.3),
    three=list(seed=42, md=0.01, nn=10, rs=.1),
  four=list(seed=42, md=0.01, nn=40, rs=.1),
  five=list(seed=42, md=0.01, nn=50, rs=.1),
  six=list(seed=42, md=.005, nn=10, rs=.1),
  seven=list(seed=42, md=.002, nn=15, rs=.1),
  eight=list(seed=42, md=.002, nn=20, rs=.1),
  nine=list(seed=42, md=.002, nn=25, rs=.1),
  ten=list(seed=42, md=.002, nn=40, rs=.3),
   eleven=list(seed=42, md=.001, nn=15, rs=.3),
  twelve=list(seed=42, md=.001, nn=25, rs=.3), 
  thirteen=list(seed=42, md=.001, nn=18, rs=.3), 
  fourteen=list(seed=42, md=.001, nn=10, rs=.3),
    fifteen=list(seed=42, md=.0005, nn=10, rs=.3),
  sixteen=list(seed=42, md=.0005, nn=10, rs=.5)
)
for(pchoice in 1:length(umap.pars)){

list2env(umap.pars[[pchoice]], .GlobalEnv)

set.seed(seed)
library(uwot)
umap.components=informative.pcs

alph=0.1
sz=2

pcaref=pca.data %>% dplyr::filter(Experiment %in% refids) %>% dplyr::select(c(umap.components))
rumap.reference <- umap(pcaref, init = "random",  min_dist = md,n_neighbors = nn, repulsion_strength=rs, ret_model=T)
rumap.reference

rumap=rumap.reference$embedding %>% as.data.frame
rumap=rumap %>% givecolnames(., ind=c(1,2), nms=c("UMAP1", "UMAP2")) %>% cbind(.,pca.data[rownames(rumap), ]) 

#
rumap.mapped.raw=umap_transform(pca.data %>% dplyr::filter(dsname %in% test.datasets) %>% dplyr::select(c(umap.components)),rumap.reference)

umap.projected= rumap.mapped.raw %>% givecolnames(., ind=c(1,2), nms=c("UMAP1", "UMAP2")) %>% cbind(.,pca.data[rownames(rumap.mapped.raw), ]) 

umap.all=rbind(rumap, umap.projected)

################################################################################
# Get datapoints of target and calculate their centroid and convex hull
################################################################################
  targetdf=umap.all %>% dplyr::filter(celltype==dataset.info$target_cell_type) %>% dplyr::select(UMAP1, UMAP2, celltype) 


 samplesdf=umap.all %>% dplyr::filter(grepl(paste(highlightgroup.contains, collapse="|"),!!sym(dataset.info$cell_type_variable))) %>% dplyr::select(UMAP1, UMAP2, celltype) 
fhulldf= targetdf[chull(targetdf), ]

fhulldf.samples= samplesdf[chull(samplesdf), ]

##########################
# make hulls for reference
##########################

allumaps.factors=lapply(c( "rbc.round1", "rbc.round2", "tmnt.full", "insulin.heparin.1", "epo.only", "ih.on","hydro.on", "epo.or.hydro", "epo.sum", "ih.sum", "hydrosum", "dev.factor", "round"
                   ), function(colorvar){

umap.all=umap.all %>% dplyr::mutate(
  epo.only=ifelse(tmnt.full %in% c("100_100", "300_100", "100_300", "300_300"), T,F ), ih.on=ifelse(tmnt.full %in% c("110_110", "310_110", "110_310", "310_310"), T,F ), hydro.on=ifelse(tmnt.full %in% c("101_101", "301_101", "101_301", "301_301"), T,F ), epo.or.hydro=ifelse(tmnt.full %in% c("100_100", "300_100", "100_300", "300_300","101_101", "301_101", "101_301", "301_301" ), T,F ), 
  epo.sum=epo.1+epo.2,
  hydrosum=hydrocortisone.1+hydrocortisone.2,
  ih.sum=insulin.heparin.1+insulin.heparin.2, 
  dev.factor=epo.sum/ih.sum,
  round=ifelse(tmnt2=="NANANA" && dsname!="Corces2016", "EDM1","EDM2" ))                   
colorlist=create.colors.if.empty(allcolors, colorvar, umap.all, 63)
                     
                     
ggplot(umap.all , aes(x=UMAP1, y=UMAP2))+
  geom_point(aes(color=factor(!!sym(colorvar)), shape=dscategory), size=sz)+
  scale_color_manual(values=colorlist[[colorvar]])+
    geom_polygon(data= fhulldf, alpha=alph, color=colorlist[[dataset.info$cell_type_variable]][dataset.info$target_cell_type], fill=colorlist[[dataset.info$cell_type_variable]][dataset.info$target_cell_type])+
  theme_classic()+theme(legend.position="bottom")
})
allumaps.factors[[1]]


sca=2
tpng("umap_conditions", wi=w*sca*1.5, he=w*sca)
print(allumaps.factors[[1]]+NoLegend()+manual.legend(allcolors, pname="condition_replicate", size=sz))

dev.off()


present.points=umap.all %>% dplyr::filter(grepl(paste(highlightgroup.contains, collapse="|"),!!sym(dataset.info$cell_type_variable))|(Experiment %in% refids)  ) %>% pull(!!sym(dataset.info$cell_type_variable)) %>% unique

umap.celltypes=ggplot(umap.all %>% filter(!grepl(paste(highlightgroup.contains, collapse="|"),!!sym(dataset.info$cell_type_variable))), aes(x=UMAP1, y=UMAP2))+
       geom_density_2d(data=umap.all %>% filter((!!sym(dataset.info$cell_type_variable) %in% !!(dataset.info$target_cell_type))), color=colorlist[[dataset.info$cell_type_variable]][dataset.info$target_cell_type], bins=5)+
  geom_point(aes(fill=celltype, shape=dscategory), color="black", size=sz, shape=21)+
  scale_fill_manual(values=allcolors$celltype[present.points])+

  geom_density_2d(data=umap.all  %>% filter(grepl(paste(highlightgroup.contains, collapse="|"),!!sym(dataset.info$cell_type_variable))), color=color.highlightgroup, breaks=c(1,3,10,20,30))+
  theme_classic()

sca=.8
tpdf(path=config$plotpath, paste_("UMAP_", dataset.info$cell_type_variable, "target", dataset.info$info$target_cell_type,"pchoice", pchoice, "version", analysis.version), wi=pw*sca*2, he=pw*sca)
print(umap.celltypes)
dev.off()

}

```


Feature selection: analysing highest loadings in informative pca's for genes and motifs

# Scan peaks for motifs

Use motifmatchr to scan all the peaks:

```{r scan_motifs, fig_width=16, fig_height=16}

mtflist=get.global.peak.annotations()
list2env(mtflist, .GlobalEnv)
```

# 24. Mixed effects model of treatments

```{r}

library(lme4)

pca.data.model=pca.data %>% dplyr::mutate(hydrocortisone.1= na2zero(hydrocortisone.1),hydrocortisone.2= na2zero(hydrocortisone.2), insulin.heparin.1= na2zero(insulin.heparin.1), insulin.heparin.2= na2zero(insulin.heparin.2), epo.1=na2zero(epo.1), epo.2=na2zero(epo.2), epo.total=as.numeric(na2zero(epo.1))+as.numeric(na2zero(epo.2)), hydro.total=as.numeric(na2zero(hydrocortisone.1))+as.numeric(na2zero(hydrocortisone.2)),inshep.total=as.numeric(na2zero(insulin.heparin.1))+as.numeric(na2zero(insulin.heparin.2) ))

lmdata=pca.data.model %>% filter(dsname %in% test.datasets)

#complex model including total amounts of reagents

model.all= lmer(formula=dist.to.centroid.pca~epo.2+epo.1+(1|hydrocortisone.1)+
                                                   (1|hydrocortisone.2)+
                                                    (1|insulin.heparin.1)+
                                                    (1|insulin.heparin.2), data=lmdata, REML=F)


mixed.effect.model.summary=tab_model(model.all, 
          show.ci = TRUE,  # Show confidence intervals
          show.p = TRUE,   # Show p-values
          show.aic=TRUE,
  show.aicc=TRUE,
          p.style = "numeric", 
  file=paste0(config$out_root, "/metadata/", "mixed_effects_model_summary", ".doc")
  )

plt.fixed.effects=ggplot(ranef(model.all) %>% as.data.frame %>% dplyr::filter(grp==1) %>% dplyr::mutate(subgroup=paste_(grpvar, grp)),aes(x=subgroup, y=condval, ymin=-condsd, ymax=condsd, fill=grpvar))+geom_col()+
  theme_classic()+
  rotatex(90)
plt.fixed.effects

################################################################################
# plot random effects
################################################################################

allcolors$subgroup= c(hydrocortisone.1=allcolors$hydrocortisone.1[2] %>% unname, hydrocortisone.2=allcolors$hydrocortisone.2[2] %>% unname, insulin.heparin.1=allcolors$insulin.heparin.1[2] %>% unname, insulin.heparin.2=allcolors$insulin.heparin.2[2] %>% unname)

random.effects.intercepts=ranef(model.all) %>% as.data.frame


yl=c(-10, 30)
plt.random.effects=ggplot(random.effects.intercepts %>% dplyr::filter(grp==1) %>% dplyr::mutate(subgroup=grpvar),aes(x=subgroup, y=condval, ymin=-condsd, ymax=condsd, fill=subgroup))+geom_col()+
  theme_classic()+
  coord_cartesian(ylim=yl)+
  scale_fill_manual(values=allcolors$subgroup)

plt.random.effects

sca=1.5
tpdf(path=config$plotpath, "pcadist_random_effects_coefficients", wi=pw*sca*1.2, he=pw*sca*.7)
print(plt.random.effects)
dev.off()


fixdf=(fixef(model.all) %>% t %>% as.data.frame)[, 2:3, drop=F]  %>%  pivot_longer(., cols=c("epo.1", "epo.2"), names_to="subgroup", values_to="value") 


plt.fixed.effects=ggplot(fixdf,aes(x=subgroup, y=value,fill=subgroup))+geom_col()+
  theme_classic()+
  coord_cartesian(ylim=yl)#+
plt.fixed.effects

sca=1.5
tpdf(path=config$plotpath, "pcadist_fixed_effects_coefficients", wi=pw*sca*.7, he=pw*sca*.7)
print(plt.fixed.effects)
dev.off()


model.none= lmer(formula=dist.to.centroid.pca~epo.1+epo.2+(1|tmnt.full), data=lmdata)


################################################################################
# incorporating metadata to the intercepts of each group
################################################################################
varrs=c( "epo.1", "insulin.heparin.1", "hydrocortisone.1", "epo.2", "insulin.heparin.2", "hydrocortisone.2")

get.treatments=function(x) pca.data %>% dplyr::filter(tmnt.full %in% x) %>% dplyr::select(tmnt.full, epo.1, insulin.heparin.1, hydrocortisone.1, epo.2, insulin.heparin.2, hydrocortisone.2 ) %>% unique()

groupdf=ranef(model.none)$tmnt.full %>% names2col(., "tmnt.full") %>% left_join(get.treatments(ranef(model.none)$tmnt.full %>% rownames), by="tmnt.full")

groupdf= groupdf %>% givecolnames(., 1, "Intercept")

lapply(varrs, function(varr){
  
ggplot(groupdf, aes(x=factor(!!sym(varr)), y=Intercept, color=factor(!!sym(varr))))+geom_point()+geom_boxplot()
})

ggplot(groupdf %>% pivot_longer(., varrs, names_to="treatment", values_to="value") %>% dplyr::filter(value==1), aes(x=treatment, y=Intercept))+geom_point()+geom_boxplot()


```


# 26. Overview of all relevant caches collected for simplicity

```{r}



### filter count data
simpleCache(paste_("counts_filter", filter.peaks, "minexpts", min.expts, "minreads",min.reads, "analysisversion", analysis.version), assignToVar="filterdata" , reload=T) 
list2env(filterdata, .GlobalEnv)
### datasets

simpleCache(paste_("prepared_dataset_version", analysis.version), assignToVar="alldatasets", reload=T)
list2env(alldatasets, .GlobalEnv)
### pca data
simpleCache(paste_("pca.data_PCA_distance_calculation_version", analysis.version), assignToVar="pca.data", reload=T)


### peaks dt global annotations

simpleCache("peaks_dt_global_annotations" %>% addversion, assignToVar="peak.gene.annotations", reload=T)
list2env(peak.gene.annotations, .GlobalEnv)


### cell type classes
simpleCache("target_DE_classlist_reference_version" %>% addversion, assignToVar="positives.celltypes", reload=T)

### in vitro classes
simpleCache("target_DE_classlist_test" %>% addversion, assignToVar="positives.invitro", reload=T)

### deseq2 dataset
simpleCache(paste0("dds_alltests_plusreference_", ifelse(filter.peaks, "filtered_", "unfiltered_"), "version", analysis.version),assignToVar="dds", reload=T)

vsd= assay(dds, vst_name)
		
simpleCache(paste0("normalised_peak_values_table_version_",analysis.version), assignToVar="norm.peak.vals", reload=T )
#colData(dds)$ml2cell.all= colData(dds) %>% as.data.frame %>% dplyr::mutate(ml2cell.all=ml2cell.assigned+ml2cell.unassigned) %>% pull(ml2cell.all)

simpleCache(paste0("normalised_peak_values_transposed_table_version_",analysis.version), assignToVar="norm.peak.vals.t", reload=T)


### Random Forest and informative PCs.

simpleCache(paste_("randomforest_model_seed",config$randomseed, "initialcomponents", config$randomforest_initial_components, "target", config$cell_type_variable, "testds_",paste(dataset.info$randomforest_test_datasets, collapse="-"),"version", analysis.version), assignToVar="rf_model", reload=T)

simpleCache(paste0("informative.pcs_rfmodel", digest::digest(rf_model), "analysisversion_", analysis.version), assignToVar="informative.pcs",reload=T) 

simpleCache(paste0("allcurves_toploadings_version_", analysis.version), assignToVar="allcurves", reload=T)

region.annot.list=annotate.peaks.global(peaks_dt_global, analysis.version)

simpleCache(paste_("selected_peak_df", max.peaks.pull, "peaks_",paste(names(allcurves), collapse="-"), "version", analysis.version ), assignToVar="selected.peak.df", reload=T)

### auc calculation cell types
simpleCache("collective.aucs.celltypes" %>% addversion, assignToVar="collective.aucs.celltypes", reload=T)
high.signal.peaks.target= collective.aucs.celltypes %>% filter(target==targetcelltype, auc>= auc.thresh) 

simpleCache("deseq2.celltypes.data" %>% addversion, assignToVar="deseq2.celltypes.data", reload=T)
list2env(deseq2.celltypes.data, .GlobalEnv)


#simpleCache(paste0("matched_motifs_allpeaks_version", analysis.version), assignToVar="mtf_mat", reload=T)

simpleCache("mtf_mat_gathered" %>% addversion, assignToVar="mtf_mat_gathered", reload=T)


simpleCache(paste_("all.peaks.celltypes.aucthresh", auc.thresh) %>% addversion, assignToVar="celltype.peak.info.list", reload=T)
list2env(celltype.peak.info.list, .GlobalEnv)
```

# 27. Plot annotation barplots for high signal peaks for different groups
```{r, fig.width=8, fig.height=8}

lapply(names(positives.celltypes), function(trg){
print(annotation.barplots(collective.aucs.celltypes %>% filter(target==trg, auc>=auc.thresh), region.annot.list , title=trg))
})

################################################################################
#proximal gene enrichments
################################################################################

promoter.overlap.list=lapply(names(positives.celltypes), function(trg){
  
annotate.close.genes(collective.aucs.celltypes) %>% as.data.frame %>% filter(target==trg, auc>=auc.thresh) %>% pull(overlapping.promoter) %>% removenas

}) %>% givename(., names(positives.celltypes))


close.tss.list=lapply(names(positives.celltypes), function(trg){
  
annotate.close.genes(collective.aucs.celltypes) %>% as.data.frame %>% filter(target==trg, auc>=auc.thresh, gene.dist<=10000) %>% pull(closest.tss) %>% removenas

}) %>% givename(., names(positives.celltypes))


he=get.hyper.enrichments(markerlist=promoter.overlap.list, gsetpars=gsetpars[1:3], colorlist=allcolors$roc.celltypes)

```

```{r, fig.width=6, fig.height=12}
he$df
he2=get.hyper.enrichments(markerlist=promoter.overlap.list, gsetpars=gsetpars[1])
he$barplots[[1]]  

 


nicecolors2=getcolors(he2$barplots[[1]], "fill")
  names(nicecolors2)=names(promoter.overlap.list)
  
  
```


Feature selection: 
a) characterise peaks with respect to the closest tss and overlapping promoters, 
b) ROC analysis to characterise target signal in the peaks. 

```{r scan_motifs, fig_width=16, fig_height=16}
################################################################################
# select which regions to use for computation
################################################################################

selected.pc.list=informative.pcs

region.options=c("overlapping_promoters" , "closest_tss")
region.selection=region.options[2]
interval1="Interval_92"
interval2="Interval_64"


simpleCache::simpleCache(paste0("peak_gene_results_broad_",region.selection,"_", paste(selected.pc.list, collapse="_"), "_", analysis.version), {


peak.gene.results=list()
peak.gene.results$regiontype=region.selection
peak.gene.results$targetcelltype=targetcelltype


for(selected.pc in selected.pc.list){
fcat(selected.pc)
simpleCache(paste0("roc_calculation_targetcelltype_", targetcelltype,"_pc_", selected.pc, region.selection, "version", analysis.version), {
peak.gene.results[[selected.pc]]=list()


peaks_dt = allcurves[[selected.pc]]$curve %>% dplyr::select(1,2,3,4,!!sym(selected.pc)) %>% dplyr::mutate(seqnames=Chr,start=Start, end=End, abspc=abs(!!sym(selected.pc))) %>% arrange(-abspc) %>% dplyr::mutate(rank=1:n()) %>% dplyr::select(Geneid,seqnames, start, end, abspc, rank, !!sym(selected.pc)) %>% GRanges


################################################################################
# obtain the closest tss for each strong-loaded peak
################################################################################

peak.gene.results[[selected.pc]]$closest_tss=geneAssignmentStrategies$closest_tss(peaks_dt, gene_annot=selGeneAnnot, window_size=MAX_DIST_GENE)


################################################################################
# obtain the closest promoter to each strong loaded peak
################################################################################

peak.gene.results[[selected.pc]]$overlapping_promoters=geneAssignmentStrategies$promo(peaks_dt, gene_annot=selGeneAnnot)
fcat(selected.pc, ". number of peaks within promoter regions:", nrow(peak.gene.results[[selected.pc]]$overlapping_promoters))
	
################################################################################
# correlate peak values with the PC
################################################################################

#prepare data frame for plotting
twointervals.df=norm.peak.vals[c(interval1, interval2), 7:ncol(vsd)] %>% t %>% as.data.frame
twointervalsdf.annotated=cbind(twointervals.df,as.data.frame(colData(dds))[rownames(twointervals.df), ])

#ggplot(twointervalsdf.annotated)+geom_point(aes(x=!!sym(interval1), y=!!sym(interval2), color=samplename))+
 # scale_color_manual(values=allcolors$celltype)


################################################################################
# correlate  PC embeddings for each sample with a peak's reads (peaks with overlapping promoters)
################################################################################
fcat("setting total intervals...")
total.intervals=nrow(peak.gene.results[[selected.pc]][[region.selection]])

if(!is.null(total.intervals)){
#selected.peaks=rearranged_pc$Geneid[1:total.intervals]  ## dplyr::select top loaded peaks in the PC
selected.peaks=peak.gene.results[[selected.pc]][[region.selection]]$Geneid[1:total.intervals] # dplyr::select peaks with overlapping promoters


selected.names=peak.gene.results[[selected.pc]][[region.selection]]$gene_symbol[1:total.intervals] # dplyr::select peaks with overlapping promoters



fcat("collecting embeddings...")
ae= get.all.embeddings(selected.pc)
sp= get.sample.peakvals(peakid=selected.peaks, samples= rownames(ae)) %>% cbind(ae, .)


################################################################################
# generate roc.curves based on the individual promoter-embedded peaks to dplyr::select those that on its own do a great job of dplyr::selecting target cells. 
################################################################################
fcat("starting roc curve loop...")
total.intervals=nrow(peak.gene.results[[selected.pc]][[region.selection]])
selected.peaks=peak.gene.results[[selected.pc]][[region.selection]]$Geneid[1:total.intervals] # dplyr::select peaks with overlapping promoters
selected.names=peak.gene.results[[selected.pc]][[region.selection]]$gene_symbol[1:total.intervals] # dplyr::select peaks with overlapping promoters
fcat("Applying ROC to intervals")
allrocs=lapply(1:total.intervals, function(xx){
pp=selected.peaks[xx]  
nn=selected.names[xx]
sp= get.sample.peakvals(peakid=pp, samples= rownames(ae)) %>% cbind(ae, .) %>% arrange(-!!sym(pp)) %>% dplyr::mutate(class=fifelse(celltype==targetcelltype, T,F ))
#sp[sp$celltype=="test", c("celltype", "class")]="?"
sp= sp %>% dplyr::filter(class!="test")


#trying new function to make roc calculation more efficient
#fcat("starting to calculate roc matrix")
rocmat=get.roc.matrix(sp, signal.col=pp, class.col="class")
#fcat("done calculating roc")
#rocmat=roc.curve(sp[, c(pp, "class")],step=0.001, true.value=TRUE, false.value=FALSE, color="black", line.width=1, plot.symbol=20,make.plot=F )
#dev.off()
au=trapezium.auc2(rocmat)
#fcat(pp, nn, au)
cat(".")
list(
  #plot=ggplot(rocmat %>% as.data.frame)+geom_path(aes(x=FPs, y=TPs))+ggtitle(nn)+geom_abline(slope=1, intercept=0, color="red", linetype="dashed")+theme_classic()+NoAxes(),
     auc=au, 
     Geneid=pp,
     gene_symbol=nn)



}) 



fcat("\nDone for all intervals of", selected.pc)


allaucs=lapply(allrocs, function(x) list(Geneid=x$Geneid, gene_symbol=x$gene_symbol, auc=unname(x$auc)) %>% data.frame) %>% Reduce(rbind, .) %>% dplyr::mutate(auc=as.numeric(auc))

allaucs.arranged=allaucs %>% dplyr::arrange(-auc) %>% dplyr::mutate(is.tf=istf(gene_symbol), rankk=1:nrow(allaucs), gene_symboln=paste0(rankk,"-", gene_symbol)) 

#ggplot(allaucs.arranged)+geom_point(aes(x= factor(gene_symboln, levels=gene_symboln), y=as.numeric(auc), color=is.tf))+rotatex(90)


#allrocs[1:30] %>% Reduce('+', .)+plot_layout(nrow=60, ncol=6) 

#list transcription factors involved
filtered.aucs=allaucs.arranged %>% dplyr::filter(auc>=auc.thresh ) 
tfaucs=allaucs.arranged %>% dplyr::filter(is.tf==T, auc>=auc.thresh ) 
tfaucs %>% pull(gene_symbol)  %>% format.enrichr

ae= get.all.embeddings(selected.pc)
sptf= get.sample.peakvals(peakid=tfaucs$Geneid, samples= rownames(ae)) %>% cbind(ae, .)


}else{
  allrocs=NULL
  allaucs=NULL
  tfaucs=NULL
  
}
## weighting these by the expression level of each peak

peak.gene.results[[selected.pc]]$allrocs=allrocs
peak.gene.results[[selected.pc]]$allaucs=allaucs
peak.gene.results[[selected.pc]]$tfaucs=tfaucs

peak.gene.results[[selected.pc]]

}, assignToVar="pclist", reload=T)
peak.gene.results[[selected.pc]]=pclist


}




peak.gene.results}, assignToVar="peak.gene.results", reload=T)
```


collect all the aucs for all peaks and order them from highest auc to the lowest. 

```{r, fig_height=10, fig_width=5}

all.relevant.pcs=union(selected.pc.list, informative.pcs)
praucs.global=lapply(all.relevant.pcs, function(pc){
peak.gene.results[[pc]]$allaucs %>% dplyr::mutate(PC=pc)
}) %>% Reduce(rbind, .) %>% dplyr::mutate(index=row_number(), is.tf=istf(gene_symbol)) %>% col2names(., "index") %>% dplyr::select(-index) %>% dplyr::arrange(-auc)


################################################################################
# keep only perfect classification peaks
################################################################################
praucs.global.filtered= praucs.global %>% dplyr::filter(auc==1)

```

Plot number of perfect signal peaks per pc
```{r}
#make pc ordered factor

all.relevant.pcs.factor=substr(all.relevant.pcs, 3, 5) %>% as.integer %>% sort %>% paste0("PC", .)

ggplot(praucs.global.filtered %>% group_by(PC) %>% summarise(counts=n()), aes(x=factor(PC, levels=all.relevant.pcs.factor), y=counts))+geom_col(fill="cyan", color="black")+ggtitle(paste("Number of", targetcelltype, "signal peaks among relevant PCs"))+theme_classic()
```
Bar plots showing highest frequencies of enhancer annotation associations

```{r, fig.height=8, fig.width=8}

annotation.barplots(praucs.global.filtered, region.annot.list )
```

Plot selected peaks

```{r fig.width=10, fig.height=10}
numplot=30
special.list=c("YOD1","UROD", "CDC20")
levsp=c("Ery","Round1","Round2", "MEP","HSC", "other")

regrouptypes= Vectorize(function(x) if(x %in% levsp[1:length(levsp)-1]) return(x) else{return(levsp[length(levsp)])}, USE.NAMES=F) 

for(gn in special.list){
filtergenes=F
selected.peaks=(closest_tss_global %>% filter(Geneid %in% high.signal.peaks.target$Geneid, gene_symbol== !!gn))$Geneid

#ae= get.all.embeddings(selected.pc)
sp= get.sample.peakvals(peakid=selected.peaks)
sp=sp %>% cbind(., (pca.data[rownames(sp), "celltype"] %>% data.frame %>% givecolnames(., nms="celltype")))
sp=sp %>% dplyr::filter(!is.na(celltype)) %>% dplyr::mutate(group=regrouptypes(celltype))

lapply(1:length(selected.peaks), function(xx){
 pp= selected.peaks[xx]
 sp = sp %>% dplyr::mutate(peak.intensity=!!sym(pp))
gname= paste0("p(", gn, ") ", pp)
d=ggplot(sp, aes(x=factor(group, levels=levsp), y=peak.intensity), color="grey")+
  geom_jitter(width=0.2)+
  #geom_col(data= sp %>% group_by(group) %>% summarise(peak.intensity=mean(as.numeric(!!sym(pp)), na.rm=T), sdev=sd(as.numeric(!!sym(pp)), na.rm=T)))+
  scale_color_manual(values=c(allcolors$celltype[levsp], other="grey"))+theme_classic()+NoLegend()+ggtitle(gname)
sca=.9
tpdf(path=config$plotpath, paste0("pointplot_peakintensity_", gname, "_by_group"), wi=pw*sca, he=pw*sca)
print(d)
dev.off()
d
}) %>% Reduce('+', .)
}
manual.legend(allcolors, "celltype")
```


 load gene signatures for gene set enrichment

use hypeR to calculate enrichments of the closest genes of the high target signal peaks
```{r fig_width=20, fig_height=30}

numbars=5###number of top results to plot in total
  auc.boundary.random=.2
  test="hypergeometric"
  statt= "JACCARD"

  markersid=""
  markerlist=list(perfect=praucs.global %>% dplyr::filter(auc==1) %>% pull(gene_symbol), high=praucs.global %>% dplyr::filter(auc>=auc.thresh) %>% pull(gene_symbol)
                  #, random=praucs.global %>% dplyr::filter(auc>=0.5-auc.boundary.random & auc <=.5+auc.boundary.random) %>% pull(gene_symbol)
  )
  #colorlist=allcolors[[finalclusvar]]

  
  
he=get.hyper.enrichments(markerlist=markerlist, gsetpars=gsetpars[1:4)  
  
    
################################################################################
# wordcloud for the gene set enrichment terms
################################################################################

remove.words= function(x, words) x[!(x %in% tolower(words))] 
wc=allhyperdfs %>% pull(label) %>% strsplit(.,split=" ") %>% unlist %>% tolower %>% remove.words(., c("in", "Descartes", "Travaglini", "Hu")) %>% table %>% as.data.frame %>% givecolnames(., nms=c("word", "count"))


ggplot(wc)+geom_text_wordcloud_area(aes(label=word, size=count))


```


motif GSEA analysis

```{r,  echo=FALSE}

################################################################################
# generate a list in which each element is all the motifs for each tf
################################################################################

mtf.group.list=list()

tmp=lapply(colnames(mtf_mat), function(x){

  if(!(x %in% names(mtf.group.list))){

  mtf.group.list[[x]]<<-mtfNames[grepl(paste0("^", x, "$"), colnames(mtf_mat))] %>% names

  }

})

################################################################################
# generate a list in which each element has all the intervals that show given TF
################################################################################
gc()
mtf.interval.list=list()

motif.count.threshold=1

tmp=lapply(1:length(mtfNames), function(x){

  if(!(x %in% names(mtf.interval.list))){

  mtf.interval.list[[names(mtfNames)[x]]]<<- mtf_mat[mtf_mat[, x]>=motif.count.threshold, x ] %>% names

  }


})


################################################################################
# calculate enrichment for each motif and find enrichment. i
################################################################################

allgseas=lapply(selected.pc.list, function(selected.pc){
loadings.pca.peaks.ranked.abs=loadings.pca.peaks.fewpcs  %>% dplyr::mutate(abspc=abs(!!sym(selected.pc))) %>% arrange(-abspc) %>% dplyr::mutate(rank=1:n())
loadings.pca.peaks.ranked.normal=loadings.pca.peaks.fewpcs  %>% dplyr::arrange(-!!sym(selected.pc)) %>% dplyr::mutate(rank=1:n())

#loadings.pca.peaks.ranked.normal

fgsea_res <- cb_fgsea(genes = loadings.pca.peaks.ranked.abs %>% dplyr::pull(Geneid) %>% head(numtop.fgsea),
                      scores = loadings.pca.peaks.ranked.abs %>% dplyr::pull(!!sym(selected.pc)) %>% head(numtop.fgsea),
                      genesets = mtf.interval.list,
                      min_size = 300,
                      nPermSimple = 10000) %>% as.data.frame
fgsea_res
}) %>% givename(., selected.pc.list)


allgseas = allgseas %>% givename(., selected.pc.list)



```


```{r}
################################################################################
#among a set of peaks, subselect some regions by gene name
################################################################################
plot.order=list(
  two=list("HSC", "NANANA_NANANA"),
  three=list("MEP", "NANANA_NANANA"),
   one=list("Ery", "NANANA_NANANA"),
  four=list("test_seruggia2", "310_310"),
    five=list("test_seruggia2", "301_301"),
  six=list("test_seruggia2", "300_300"),
  seven=list("test_seruggia2", "311_311")
)

GENOME_BIN_SIZE <- 500 # size of bins
GENOME_FLANK_SIZE <- 5000 # extend regions of interest by X bp in each direction


fg <- c("HBB", "HBG1", "HBG2") 


make.atac.trackplot= function(focusGenes, dds, startextra=10000, endextra=1000, geneAnnot=geneAnnot,facet.var1="celltype", plot.order=plot.order, GENOME_BIN_SIZE=500, GENOME_FLANK_SIZE=5000 ){


selRegions <- dtToGr(as.data.table(geneAnnot)[type=="gene" & gene_name%in%focusGenes & type=="gene",.(chrom=seqnames,start=start-startextra,end.original=end, start.original=start, end=end+endextra,reg_id=gene_name,gene_name)], metaCols=c("reg_id", "gene_name", "start.original", "end.original"))
names(selRegions) <- selRegions$reg_id
selRegions <- selRegions[order(factor(names(selRegions), levels=focusGenes))]

selExonAnnot <- geneAnnot[ geneAnnot$type=="exon" & geneAnnot$gene_type=="protein_coding" & (geneAnnot$gene_name %in% focusGenes),] %>% as.data.frame %>% filter(start!=end) %>% GRanges

sz <- sizeFactors(dds) # size factors calculated for normalization from DESeq2
#rm(dds)

#Calculate coverage in bins through the selected regions:

bampaths=lapply(dataset.info$dataset_paths_bam[c(as.logical(dataset.info$is_reference) | as.logical(dataset.info$is_test))], function(x) paste0(x, list.files(path = x, pattern=".bam$"))) %>% Reduce(c,. )

getfilename=function(x){ parts=( x %>% strsplit(., split="/"))[[1]]; editname(parts[length(parts)])}
formatfc= function(x) data.table(Chr=as.character(seqnames(x)), Start=start(x),End=end(x))
genestring=paste(focusGenes, collapse="-")

 simpleCache(paste0("atac_focused_coverage_", genestring, "leftextend_", startextra, "rightextend_", endextra, "_analysis_", analysis.version), {
  # utility function to calculate the coverage from multiple BAM files in a selected genomic regions (divided into bins):
 # execute the utility function for all our samples and the previously selected regions of interest:
	all.pileups=parallel::mclapply(1:length(bampaths), function(x, bp, r, rs, nt){
  
simpleCache::simpleCache(paste0("pileup_genes_",genestring,"bam", getfilename(bp[x]), "_regionsid_",digest::digest(r),"analysis", analysis.version), {
  dtCov <- getCoverageInInterval(bp[x], r, res=rs, nthreads=nt)

 }, assignToVar="dtCov", reload=T)
  dtCov
  
  },bp=bampaths, r=selRegions,rs=50, nt=1, mc.cores=20)
 
dtCov=all.pileups %>% bind_rows
	# extend metadata:
	dtCov <- dtCov %>% as.data.frame %>% dplyr::mutate(Experiment=editname(as.character(library_name)))
	dtCov <- merge(pca.data, dtCov, by.x="Experiment", by.y="Experiment")
	dtCov=as.data.table(dtCov)[, `:=`(c("reg_id", "chrom", "start", "end", "gene_name"), as.data.table(selRegions)[dtCov$reg_id, .(reg_id, seqnames, as.numeric(start), as.numeric(end), gene_name)])]
	dtCov[, reg_info:= sprintf("%s\n%s:%s-%s (%.1f kb)", reg_id, chrom, prettyIntegers(start), prettyIntegers(end), (end-start)/1000)]
		
	# scale coverage:
dtCov=	data.table(dtCov)[, size_factor := 1/sz[Experiment]] # use the same size factors as used to scale read counts in heatmaps / PCA / etc.
	dtCov[, norm_val := count*size_factor]

	
dtCov}, assignToVar="dtCoV", reload=T)	

#finding general genes in locus

gnsAnnot=geneAnnot %>% as.data.frame %>% filter(type=="gene") %>% GRanges
assoc <- as.data.table(GenomicRanges::findOverlaps(selRegions,gnsAnnot, ignore.strand=T))
		assoc <- assoc[, .(seqnames=(seqnames(gnsAnnot) %>% as.vector)[subjectHits],strand= (strand(gnsAnnot) %>% as.vector)[subjectHits], gr_index=queryHits, gene_symbol=gnsAnnot@elementMetadata$gene_name[subjectHits], start=start(gnsAnnot)[subjectHits], end=end(gnsAnnot)[subjectHits])]

		assoc=assoc %>% filter(!grepl("^OR", gene_symbol) & !grepl("^ENS", gene_symbol))
		
		invertstart=Vectorize(function(start, end, strand, selection){
		  if(strand=="-"){
		    s=end
		    e=start
		  }else{
		      s=start
		      e=end
		      }
fin=list(start=s, end=e)
fin[[selection]]}, USE.NAMES=F)

		
		locus.genes=assoc[!duplicated(assoc$gene_symbol),] %>% dplyr::mutate(ind=1:n(), midpoint=(end+start)/2) %>% dplyr::mutate(start2=invertstart(start, end, strand, "start"), end=invertstart(start, end,strand, "end"), start=start2)
		
		phasing=0.3
		
		tssdf=geneAnnot %>% as.data.frame %>% filter(type=="gene", gene_name %in% locus.genes$gene_symbol) %>% GRanges %>% promoters(., 0,1) %>% as.data.frame %>% dplyr::mutate(ind=1:n(), midpoint=(end+start)/2)
		
				exondf=geneAnnot %>% as.data.frame %>% filter(type=="gene", gene_name %in% locus.genes$gene_symbol) %>% GRanges %>% promoters(., 0,1) %>% as.data.frame %>% dplyr::mutate(ind=1:n(), midpoint=(end+start)/2)


fcat("making figure panels")
allpanels=lapply(focusGenes, function(genechoice){ 

coverage.df=dtCov %>% filter((start.original-bin_start)<=GENOME_FLANK_SIZE, (bin_end-end.original)<=GENOME_FLANK_SIZE ) %>% group_by(c("start.original", "end.original","celltype", "bin_id","bin_start","bin_end", "rbc.round1", "rbc.round2", "epo.1", "hydrocortisone.1", "insulin.heparin.1", "epo.2", "hydrocortisone.2", "insulin.heparin.2", "tmnt.full")) %>% summarise(sum_norm_val=sum(as.numeric(norm_val)), mean_norm_val=mean(as.numeric(norm_val))) %>% as.data.frame

xlima= min(coverage.df$bin_start)
xlimb= max(coverage.df$bin_start)
ylima=0
ylimb=max(coverage.df$mean_norm_val)
phasing=1
#color.levels=coverage.df %>% pull(color.var) %>% unique %>% sort
gglocus=		ggplot(locus.genes, aes(x=start, xend=end, y=ind, yend=ind))+geom_segment( arrow = arrow(length = unit(0.1, "inches"), ends="last", type = "closed"))+geom_text(inherit.aes=F, aes(x=midpoint, y=ind+phasing, label=gene_symbol))+
  geom_segment(data=tssdf, inherit.aes=F, aes(x=start, xend= start, y=ind-phasing, yend=ind+phasing))+
  coord_cartesian(xlim=c(xlima, xlimb))+theme_classic()+NoAxes()


map.notreatment=function(x) ifelse(x=="NANANA_NANANA", "", x)

cc<<-1
allcovplots=lapply(plot.order, function(x){
val1=x[[1]]; val2=x[[2]] 
fcat(val1)
p=ggplot(coverage.df %>% filter(!!sym(facet.var1)==val1, !!sym(facet.var2)==val2), aes(x=bin_start, y=as.numeric(mean_norm_val), fill=!!sym(facet.var1)))+
  geom_col()+
 # geom_vline(aes(xintercept=start.original), color="red")+
  theme_classic()+
  coord_cartesian(xlim=c(xlima, xlimb), ylim=c(ylima, ylimb))+
  ggtitle(paste0(val1,". ", map.notreatment(val2)))+
  scale_fill_manual(values=allcolors[[facet.var1]])+NoLegend()+theme(
    axis.title.y = element_blank())#+#+
  #facet_wrap(vars(!!sym(facet.var1), !!sym(facet.var2)), nrow=length(facet.var1.include)*length(facet.var2.include), ncol=1)

if(cc==length(plot.order)){
 p=p
}else{
    p= p+theme(
    axis.title.x = element_blank(),       # Remove x-axis label
    axis.text.x = element_blank(),        # Remove x-axis tick labels
    axis.ticks.x = element_blank(),       # Remove x-axis ticks
    axis.line.x = element_blank()
      # Remove x-axis line
  )
 cc<<-cc+1 
}
  
p
})


createlayout= function(plotids, numlines, widths){
 
  lapply(1:length(plotids), function(y){  
    
  lapply(1:numlines[y], function(x){
    #fcat(plotids[y])
    rep(plotids[y], widths) %>% paste(., collapse="") %>% paste0(., "\n") 
    
  }) %>% Reduce(paste0, .)
    
  }) %>% Reduce(paste0, .)  
}

plotletters=LETTERS[1:(length(allcovplots)+1)]
numrows=c(3, rep(1, length(allcovplots)))
ll=createlayout(plotletters, numrows, 5)

ll="AAAAA
AAAAA
AAAAA
BBBBB
CCCCC
DDDDD
EEEEE
FFFFF
GGGGG
HHHHH"
 fp= wrap_plots(A=gglocus, B=allcovplots[[1]], C=allcovplots[[2]], D=allcovplots[[3]], E=allcovplots[[4]], F=allcovplots[[5]], G=allcovplots[[6]],H=allcovplots[[7]], design=ll)
  #facet_grid(rows=vars(!!sym(facet.var1)), cols=vars(!!sym(facet.var2)))
  sca=1
 tpdf(path=config$plotpath, paste0("chromatinpanel_", genechoice), wi=pw*sca*1.2, he=pw*sca*2.2)
 print(fp)
  dev.off()
  print(fp)
  })
 #gglocus/ggcov


```



# 28 Deeptools script preparations

```{r}

################################################################################
# Fig 2 b code to produce a deeptools command to produce a developmental sequence in a heatmap
################################################################################

howmany=1000
#spd=selected.peak.df %>% group_split(PC) %>% lapply(., function(x) x %>% head(howmany)) %>% Reduce(rbind, .)
#spd=all.peaks.celltypes.deseq2 %>% lapply(., function(x) x[1:howmany]) %>% Reduce(c, .)
spd=high.signal.peaks.celltypes%>% pull(Geneid) %>% head(howmany)

ctypes=c("HSC", "CMP", "MEP","Bcell", "Ery")
cappends=c(F,T,T,T, T)
lapply(1:length(ctypes), function(xx){
prepare.deeptools.script(test.class.variable="celltype", ref.sample.number=2, max.test.samples=10,norm.peak.vals=norm.peak.vals,meta=meta, test.class=ctypes[xx], dataset.info=dataset.info, peak.list=list(high.loading.peaks=spd),peaks.id = "only-ery-peaks-new-parameters", append=cappends[xx], heatmap.height=10, specific.samples=c("SRX1427855","SRX1427859","SRX1427797"))
}  )
  
```

deeptools code to show the high signal peaks (for all celltypes) for all replicates of the most optimal condition

```{r}

chosen.condition="300_300|100_100|101_101|111_111|311_301|300_310|300_301|300_311|310_310|301_301|311_311"
######################
# sorting based on a test sample to reveal more prominent lacking regions
######################
existent.signal.peaks=high.signal.peaks.celltypes[lapply(high.signal.peaks.celltypes, function(x) length(x)) %>% Reduce(c, .)>0]

comparison.signal.peaks=existent.signal.peaks

### incorporate all peaks that negatively identify the target

comparison.signal.peaks$Ery.negative=collective.aucs.celltypes %>% filter(target=="Ery", auc<=1-auc.thresh) %>% pull(Geneid)

deeptools.tmnt.indfiles=prepare.deeptools.script(test.class.variable="tmnt.full", ref.sample.number=2, max.test.samples=NULL,norm.peak.vals=norm.peak.vals,meta=meta, test.class=chosen.condition, dataset.info=dataset.info, peak.list=comparison.signal.peaks,peaks.id = "many_invitro_plus_ery_inverse_auc95" %>% addversion, heatmap.height=28, sort.using.samples=3, num.processors=10)

```

### prepare script with specific samples to show in the panel
```{r}
#here we bypass all arguments and perform the deeptools on specific samples (except for the reference)
prepare.deeptools.script(test.class.variable="celltype", ref.sample.number=2, max.test.samples=10,norm.peak.vals=norm.peak.vals,meta=meta, test.class="Ery", dataset.info=dataset.info, peak.list=list(high.loading.peaks=spd),peaks.id = "only-ery-peaks-specific-samples-new-parameters", append=F, heatmap.height=10, specific.samples=c("SRX1427855","SRX1427859","SRX1427797"))
```


```{r}

all.round1= meta %>% pull(tmnt1) %>% unique %>% removegene(., "NANANA") %>% paste_(., "NANANA")

all.celltypes= meta %>% filter(dsname=="Corces2016") %>% pull(celltype) %>% unique

vec=all.celltypes
classvar="celltype"
allappends=rep(T, length(vec))
allappends[1]=F

all.final.bigwigs=lapply( 1:length(vec), function(xx) {

prepare.bigwigmerge(test.class.variable=classvar, ref.sample.number=2, max.test.samples=10,norm.peak.vals=norm.peak.vals,meta=meta, test.class=vec[xx], dataset.info=dataset.info, peak.list=list(high.loading.peaks=spd),peaks.id = "", append.to.file=allappends[xx], heatmap.height=10, specific.samples=NULL)$final.bigwig

}) %>% Reduce(c, .)

names(all.final.bigwigs)=vec

all.final.bigwigs.f=grep("CD34", all.final.bigwigs, value=T, invert=T)

  
```


```{r}
prepare.bigwigmerge(test.class.variable="tmnt.full", ref.sample.number=2, max.test.samples=10,norm.peak.vals=norm.peak.vals,meta=meta, test.class="300_300", dataset.info=dataset.info, peak.list=list(high.loading.peaks=spd),peaks.id = "", append.to.file=F, heatmap.height=10, specific.samples=NULL)$final.bigwig
```

prepare deeptools with the merged bigwigs
```{r}
prepare.deeptools.script(test.class.variable="celltype", ref.sample.number=2, max.test.samples=10,norm.peak.vals=norm.peak.vals,meta=meta, test.class="Ery", dataset.info=dataset.info, peak.list=list(high.loading.peaks=spd),peaks.id = "merged_bigwigs_round1_ery_peaks", append=F, heatmap.height=10, selected.bigwigs=all.final.bigwigs)
```



```{r}

ery.bigwig=prepare.bigwigmerge(test.class.variable="celltype", ref.sample.number=2, max.test.samples=10,norm.peak.vals=norm.peak.vals,meta=meta, test.class="Ery", dataset.info=dataset.info, peak.list=list(high.loading.peaks=spd),peaks.id = "", append.to.file=F, heatmap.height=10, specific.samples=NULL)$final.bigwig


```
## Create high signal peak deeptools accessibility panel
```{r}

existent.signal.peaks=high.signal.peaks.celltypes[lapply(high.signal.peaks.celltypes, function(x) length(x)) %>% Reduce(c, .)>0]



prepare.deeptools.script(test.class.variable="celltype", ref.sample.number=2, max.test.samples=10,norm.peak.vals=norm.peak.vals,meta=meta, test.class="all", dataset.info=dataset.info, peak.list=existent.signal.peaks,peaks.id = paste0("highsignalpeaks_celltypes_AUC_", auc.thresh), append=F, heatmap.height=10, selected.bigwigs=all.final.bigwigs.f[names(existent.signal.peaks)])


###   taking a step back, running computeMatrix on all peaks for normalisation
allpeaks=list(allpeaks=annotation.peaks %>% rownames)

prepare.deeptools.script(test.class.variable="celltype", ref.sample.number=2, max.test.samples=10,norm.peak.vals=norm.peak.vals,meta=meta, test.class="all", dataset.info=dataset.info, peak.list=allpeaks,peaks.id = "ALLPEAKS_celltypes", append=F, heatmap.height=10, selected.bigwigs=all.final.bigwigs.f[names(existent.signal.peaks)])

```

prepare deeptools script after clustering peaks with different patterns
```{r}


prepare.deeptools.script(test.class.variable="tmnt.full", ref.sample.number=2, max.test.samples=10,norm.peak.vals=norm.peak.vals,meta=meta, test.class=chosen.condition, dataset.info=dataset.info, peak.list=peak.clustering.result$peak.list,peaks.id = "peak_discrepancy_subtypes" %>% addversion, heatmap.height=28, sort.using.samples=3, num.processors=10)

```




# 29. Isolate and Prepare the concordance peaks. Purify the discordant peaks by clustering with DeepTools


```{r}
################################################################################
# function to import and remap the peak matrix
################################################################################

#matfile="/home/luis/bioinf_isilon/Research/HALBRITTER/Internal/out/ML2Cell/deeptoolsrerun/2024-10-02_deeptools_ref_Ery_tmnt.full_300_300-310_310-301_301-311_311_all_high_signal_peaks_celltypes_version_20240925.broad/integrated_matrix.gz" %>% prep.dir.for.in.root

#matfile.heatmap="/home/luis/bioinf_isilon/Research/HALBRITTER/Internal/out/ML2Cell/deeptoolsrerun/2024-10-02_deeptools_ref_Ery_tmnt.full_300_300-310_310-301_301-311_311_all_high_signal_peaks_celltypes_version_20240925.broad/heatmap_matrix.gz" %>% prep.dir.for.in.root

#matfile.sortedregions="/home/luis/bioinf_isilon/Research/HALBRITTER/Internal/out/ML2Cell/deeptoolsrerun/2024-10-02_deeptools_ref_Ery_tmnt.full_300_300-310_310-301_301-311_311_all_high_signal_peaks_celltypes_version_20240925.broad/sorted_regions_heatmap.bed" %>% prep.dir.for.in.root

umap.pars=list(extend.from.center=20, 
  ncomp=60, 
  rs=5, 
  md=1,
  nn=20, 
  cluster.resolution=0.8, 
  coll="louvain.cluster"
  
)


chosen.condition2="300_300"
######################
# sorting based on a test sample to reveal more prominent lacking regions
######################
existent.signal.peaks=high.signal.peaks.celltypes[lapply(high.signal.peaks.celltypes, function(x) length(x)) %>% Reduce(c, .)>0]

comparison.signal.peaks=existent.signal.peaks


simpleCache(paste_("remake_all.peaks.celltypes_peaks_screened_celltypes",gsub(" ", "-", paste(selected.celltype.list, collapse="-")), max.peaks.pull, "aucthresh", auc.thresh) %>% addversion, {
 
highs=lapply(selected.celltype.list, function(x) collective.aucs.celltypes %>% filter(auc>=auc.thresh, target== !!x) ) %>% bind_rows()  


high.peak.annot =highs %>% arrange(factor(target, levels=selected.celltype.list), -auc)  %>% dplyr::select(Geneid,target, auc)
high.peak.annot=high.peak.annot %>% dplyr::mutate(dup=duplicated(high.peak.annot$Geneid)) %>% filter(!dup) %>% as.data.frame %>%  col2names(., "Geneid")
high.peaks=high.peak.annot %>% pull(Geneid) %>% unique

all.peaks.celltypes.auc=lapply(selected.celltype.list, function(x) collective.aucs.celltypes %>% filter(auc>=auc.thresh, target== !!x) %>% pull(Geneid) ) %>% givename(., selected.celltype.list)


high.samples=lapply(highs %>% pull(target) %>% unique, function(x)  get.samples.from.class(x, positives.celltypes)) %>% Reduce(c, .)


high.matrix.numbers=get.sample.peakvals(peakid=high.peaks,samples=high.samples ) %>% giverownames(., high.samples)

high.matrix.numbers.t=high.matrix.numbers %>% t 
high.matrix.numbers.t=high.matrix.numbers.t[get.variant.rows(high.matrix.numbers.t), ]
hmpeaks=rownames(high.matrix.numbers.t)

celltype.peak.info.list=list(
  all.peaks.celltypes.auc=all.peaks.celltypes.auc,
  selected.celltype.list=selected.celltype.list,
  auc.thresh=auc.thresh, 
  highs=highs,
  high.peak.annot=high.peak.annot,
high.peaks=high.peaks,
  hmpeaks=hmpeaks,
  high.samples=high.samples,
  high.matrix.numbers=high.matrix.numbers,
  high.matrix.numbers.t=high.matrix.numbers.t
)
}, assignToVar="celltype.peak.info.list", reload=T)

### incorporate all peaks that negatively identify the target

comparison.signal.peaks$Ery.negative=collective.aucs.celltypes %>% filter(target=="Ery", auc<=1-auc.thresh) %>% pull(Geneid)


deeptools.tmnt.indfiles=prepare.deeptools.script(test.class.variable="tmnt.full", ref.sample.number=2, max.test.samples=10,norm.peak.vals=norm.peak.vals,meta=meta, test.class=chosen.condition2, dataset.info=dataset.info, peak.list=comparison.signal.peaks,peaks.id = "all_high_signal_peaks_celltypes_plus_ery_inverse_auc95" %>% addversion, heatmap.height=28, sort.using.samples=3, num.processors=10, date.use="2024-10-15")


deeptools.tmnt.indfiles.discordant=prepare.deeptools.script(test.class.variable="tmnt.full", ref.sample.number=2, max.test.samples=10,norm.peak.vals=norm.peak.vals,meta=meta, test.class=chosen.condition2, dataset.info=dataset.info, peak.list=comparison.signal.peaks[c("MEP", "Ery.negative")],peaks.id = "all_discordant_peaks_ery_inverse_mep" %>% addversion, heatmap.height=28, sort.using.samples=3, num.processors=10, date.use='2024-11-25')




deeptools.tmnt.indfiles=prepare.deeptools.script(test.class.variable="tmnt.full", ref.sample.number=2, max.test.samples=10,norm.peak.vals=norm.peak.vals,meta=meta, test.class=chosen.condition2, dataset.info=dataset.info, peak.list=list(sortedpeaks=rownames(all.block.mat)),peaks.id = "all_sortedpeaks_celltypes_plus_ery_inverse_auc95" %>% addversion, heatmap.height=28, sort.using.samples=3, num.processors=10, date.use=NULL)


deeptools.tmnt.indfiles=prepare.deeptools.script(test.class.variable="tmnt.full", ref.sample.number=2, max.test.samples=10,norm.peak.vals=norm.peak.vals,meta=meta, test.class=chosen.condition2, dataset.info=dataset.info, peak.list=list(sortedpeaks=rownames(all.block.mat)),peaks.id = "all_sortedpeaks_celltypes_plus_ery_inverse_auc95" %>% addversion, heatmap.height=28, sort.using.samples=3, num.processors=10, date.use=NULL)







simpleCache("peak_clustering_workflow_result_best_treatment" %>% addversion,{
peak.clustering.workflow.result=peak.clustering.workflow(matfile=deeptools.tmnt.indfiles$path.matrix, matfile.heatmap=deeptools.tmnt.indfiles$path.heatmap.matrix, matfile.sortedregions=deeptools.tmnt.indfiles$path.sortedregions, nsamples=length(deeptools.tmnt.indfiles$all.bigwigs),which.samples.umap=1: (length(deeptools.tmnt.indfiles$selected.bigwigs)+1),umap.pars=umap.pars, annotation.peaks=annotation.peaks)

peak.clustering.workflow.result

}, assignToVar="peak.clustering.workflow.result", reload=T)



simpleCache("peak_clustering_workflow_result_best_treatment_discordant" %>% addversion,{
peak.clustering.workflow.result=peak.clustering.workflow(matfile=deeptools.tmnt.indfiles.discordant$path.matrix, matfile.heatmap=deeptools.tmnt.indfiles.discordant$path.heatmap.matrix, matfile.sortedregions=deeptools.tmnt.indfiles.discordant$path.sortedregions, nsamples=length(deeptools.tmnt.indfiles.discordant$all.bigwigs),which.samples.umap=1: (length(deeptools.tmnt.indfiles.discordant$selected.bigwigs)+1),umap.pars=umap.pars, annotation.peaks=annotation.peaks)

peak.clustering.workflow.result

}, assignToVar="peak.clustering.workflow.result", reload=T)


get.deeptools.cluster.peaks= function(peak.clustering.wokflow.result, cluster)  peak.clustering.workflow.result$matts %>% filter(deepTools_group==!!cluster) %>% pull(Geneid)
  
get.close.tfs=function(peaks) closest_tss_global[Geneid %in% peaks] %>% dplyr::mutate(is.tf=istf(gene_symbol)) %>% dplyr::filter(is.tf) %>% arrange(gene_dist)  %>% group_by(gene_symbol) %>% summarise(dist.mean=mean(gene_dist), counts=n(), dist.sd=sd(gene_dist)) %>% as.data.frame %>% arrange(dist.mean)

get.deeptools.heatmap= function(peak.clustering.workflow.result, cluster, breaks=seq(0,4,.1)) peak.clustering.workflow.result$matth[grepl(cluster, peak.clustering.workflow.result$matts$deepTools_group), ] %>% row.heatmap(., breaks=breaks, color=colorRampPalette(c( "white", "dodgerblue", "darkblue"))(length(breaks)))

get.tfbs= function(peaks, tfs=NULL){
  if(is.null(tfs)){
  tfs=1:ncol(mtf_mat_gathered)
    }
    
  mtf_mat_gathered[intersect(peaks,rownames(mtf_mat_gathered)), tfs]
}
```


```{r}

simpleCache(paste_("remake_all.peaks.celltypes_peaks_screened_celltypes",gsub(" ", "-", paste(selected.celltype.list, collapse="-")), max.peaks.pull, "aucthresh", auc.thresh) %>% addversion, assignToVar="celltype.peak.info.list", reload=T)
list2env(celltype.peak.info.list, .GlobalEnv)

chosen.condition2="300_300"
######################
# sorting based on a test sample to reveal more prominent lacking regions
######################
existent.signal.peaks=high.signal.peaks.celltypes[lapply(high.signal.peaks.celltypes, function(x) length(x)) %>% Reduce(c, .)>0]

comparison.signal.peaks=existent.signal.peaks

### incorporate all peaks that negatively identify the target

comparison.signal.peaks$Ery.negative=collective.aucs.celltypes %>% filter(target=="Ery", auc<=1-auc.thresh) %>% pull(Geneid)


simpleCache("peak_clustering_workflow_result_best_treatment_discordant_clustered" %>% addversion,{
peak.clustering.workflow.result=peak.clustering.workflow(matfile=deeptools.tmnt.indfiles.discordant$path.matrix, matfile.heatmap=deeptools.tmnt.indfiles.discordant$path.heatmap.matrix.clustered, matfile.sortedregions=deeptools.tmnt.indfiles.discordant$path.sortedregions.clustered, nsamples=length(deeptools.tmnt.indfiles.discordant$all.bigwigs),which.samples.umap=1: (length(deeptools.tmnt.indfiles.discordant$selected.bigwigs)+1),umap.pars=umap.pars, annotation.peaks=annotation.peaks)

peak.clustering.workflow.result

}, assignToVar="peak.clustering.workflow.result", reload=T)


######## directlu plotting peaks

sma=vsd[concordance.peaks$discordant, c(refids, test.ids.list[[3]]), drop=F] %>% as.data.frame %>% t %>% as.data.frame %>% names2col(., "Experiment") %>% pivot_longer(., starts_with("Interval"), names_to = "Geneid", values_to="score")
mixtab=sma %>% left_join(., pca.data, by="Experiment")

tpdf("pointplot_discordant_vsd_combo",path=config$plotpath, width=10*sca)
ggplot(, aes(x=Geneid, y=score))+geom_point_rast(data=mixtab %>% dplyr::filter(grepl("^SRX", Experiment)))+geom_point_rast(data=mixtab %>% dplyr::filter(grepl("^RBC", Experiment)), aes(color=rbc.combo))+rotatex(90)+scale_color_manual(values=allcolors[["target"]]) 
dev.off()



################################################################################
# Collect the concordant and discordant peaks
################################################################################

chosen.condition3="8G|5E|IL41|IL41|IL42|TGFB1|TGFB2"
chosen.condition4="test_8G|test_3-0-0_3-0-0|test_5E|test_IL41|test_IL42|test_TGFB1|test_TGFB2"
chosen.condition5=c("Ery", "8Gv","5Ev", "IL4-1v","IL4-2v","TGF-1v", "TGF-2v")

analysis.version2="20240925.broad" #peaks stor
simpleCache("concordance_peaks" %>% addversion2, {
concordance.peaks=list(
concordant.open=high.signal.peaks.celltypes$Ery, 
discordant=peak.clustering.workflow.result$matts %>% dplyr::filter(deepTools_group=="cluster_4") %>% pull(Geneid),
concordant.closed=comparison.signal.peaks[names(comparison.signal.peaks)[3:8]] %>% Reduce(c, .) %>% unique
)
}, assignToVar="concordance.peaks", reload=T)



```


```{r flag}

  
meta3= meta2 %>% dplyr::mutate( Condition=ifelse(dscategory=="reference", celltype, ifelse(is.na(rbc.combo), tmnt.full, ifelse(!grepl("Round", rbc.combo), rbc.combo, tmnt.full))))

meta4=conditional.suffix(meta3, search.var="dsname", target.var="Condition", pattern="Seruggia2025-3", suf="v") %>% generate.full.paths %>% dplyr::mutate(bigwigpath.merged= ifelse(dsname=="Seruggia2025-3", gsub("broadpeak", "broadpeak_wmerge", bigwigpath.merged), bigwigpath.merged))
  
deeptools.condition.validation=prepare.deeptools.script2(test.class.variable="Condition", ref.sample.number=2, max.test.samples=20,meta=meta4, test.class=chosen.condition5, dataset.info=dataset.info, peak.list=concordance.peaks,peaks.id = "concordance_peaks2-validationmerge" %>% addversion, heatmap.height=28, sort.using.samples=1, num.processors=10, run.external=F, usemerged = F, replace = F, one.per.class = F )

Sys.setenv(DEEPTOOLSDIR = deeptools.condition.validation$outfile.scripts.list$archive)

file.exists(deeptools.condition.validation$selected.bigwigs)

```



```{r flag}
dtp=deeptools.condition.validation
dtpid=digest::digest(dtp)
#current id 6ac19e4665ca9ff2cdd19c3656e4a452
simpleCache(paste0("deeptools_data_validation_concordance_peaks_id_", dtpid) %>% addversion,{
deepdata=read.deeptools(dtp,annotation.peaks=annotation.peaks,masks=masks)

deepdata

}, assignToVar="deepdata", reload=T)
```

## 31. Analyse predicted treatments

get concordance peaks and motifs workspace
```{r}

simpleCache("concordance_peaks" %>% addversion, {
concordance.peaks=list(
concordant.open=high.signal.peaks.celltypes$Ery, 
discordant=peak.clustering.workflow.result$matts %>% dplyr::filter(deepTools_group=="cluster_4") %>% pull(Geneid),
concordant.closed=comparison.signal.peaks[names(comparison.signal.peaks)[3:8]] %>% Reduce(c, .) %>% unique
)
}, assignToVar="concordance.peaks", reload=T)


simpleCache("motifs_workspace" %>% addversion,{
  package.vars(concordance.peaks, concordance.peaks.unique, mtf_mat_gathered, lst.v, closest_tss_global, meta3, meta4, testids)
  
  }, assignToVar="motifs.workspace", reload=T )

simpleCache("motifs_workspace_lean" %>% addversion,{
  motifs.workspace$mtf_mat_gathered=NULL
  motifs.workspace
  }, assignToVar="mw", reload=T )



venn_obj <- gplots::venn(mw$concordance.peaks)
concordance.peaks.unique=attr(venn_obj, "intersections")[c("concordant.open", "discordant", "concordant.closed")]


```



33. Calculate DE of all in vitro conditions towards the target and the winner

```{r flag}
################################################################################
# find the differences to ery
################################################################################

simpleCache("all_DE_invitro_vs_reference_individual" %>% addversion, {
all.des=de.matches.invitro.workflow.individual(envlist=list(dds=dds, dataset.info=dataset.info, meta2=meta2, peaks=mw$concordance.peaks.unique), reload=T, ref=config$target_cell_type, refvar="celltype", cores=1, comparison.id=paste0("vs",config$target_cell_type, "_concordanceunique_individual"))
}, assignToVar="all.des.individual.ery", reload=T)



################################################################################
# each comparison must have more than mr reads in at least me experiments (in one
# of the conditions
################################################################################
mr=5; me=2
simpleCache(paste_("all_DE_invitro_vs_5E_ds5_individual_ref_minreads",mr, "minexpts", me) %>% addversion, {
all.des=de.matches.invitro.workflow.individual(envlist=list(dds=dds, dataset.info=dataset.info, meta2=metadata.alldatasets.formatted, peaks=mw$concordance.peaks.unique), reload=F, ref="5E_ds5", refvar="Condition", cores=12, comparison.id=paste0("vs","5E_ds5", "_concordanceunique_individual_minreads_",mr, "minexpts", me), cutoff.mean=0, min.reads=mr, min.expts=me)
}, assignToVar="all.des.individual.5E5", reload=T)


################################################################################
# comparing all peaks
################################################################################

mr=5; me=2
simpleCache(paste_("all_DE_allpeaks_invitro_vs_5E_ds5_individual_ref_minreads",mr, "minexpts", me) %>% addversion, {
all.des=de.matches.invitro.workflow.individual(envlist=list(dds=dds, dataset.info=dataset.info, meta2=metadata.alldatasets.formatted, peaks=rownames(dds)), reload=F, ref="5E_ds5", refvar="Condition", cores=12, comparison.id=paste0("vs","5E_ds5", "_allpeaks_individual_minreads_",mr, "minexpts", me), cutoff.mean=0, min.reads=mr, min.expts=me)
}, assignToVar="all.des.individual.5E5", reload=T)


################################################################################
# focusing on discordant peaks only
################################################################################ 

vconditions=c( "8G_ds3","8G_ds5","5E_ds3","IL41_ds5", "IL42_ds5", "TGFB1_ds5", "TGFB2_ds5")
vconditions2=c("IL41_ds5", "IL42_ds5", "TGFB1_ds5", "TGFB2_ds5")

all.des=Reduce(c, all.des.individual.5E5)

discordant.corrected.all=lapply(all.des[vconditions2], function(x) if(!is.null(x)) x %>% arrange(padj) %>% dplyr::mutate(padj2=p.adjust(pvalue, method="BH"), padjbonf=pvalue*n()) %>% names2col(., "Geneid") %>% select(Geneid, baseMean, log2FoldChange, pvalue, padj, padjbonf) %>% annotate.peak.table(., annotation.peaks=annotation.peaks) %>% dplyr::filter(padj<=0.01) %>% arrange(log2FoldChange))

lst.v=targeted.changes.analysis(all.des[vconditions2], mw$concordance.peaks, pval=Inf, thr=0, facet="type")
exclude="other"
hits=lapply(all.des[vconditions2], function(x) if(!is.null(x)) x %>% arrange(padj) %>% filter(padj<=0.05) %>% names2col(., "Geneid") %>% dplyr::mutate(concordance=check.concordance(Geneid)) %>% dplyr::filter(concordance!=exclude) %>% annotate.peak.table(., annotation.peaks = annotation.peaks) %>% arrange(factor(concordance, levels=c("concordant.open", "discordant", "concordant.closed", "other"))))

hits.compiled=hits %>% Reduce(rbind, .)

dump.table(hits.compiled)

```



```{r}
comparison.id="allvs_5E_ds5_concordanceunique_batch"
refcondition="5E_ds5"
refvar="Condition"
selected.peaks=NULL
refexpts=metadata.alldatasets.formatted %>% as.data.frame %>%
  dplyr::filter(grepl(refcondition, !!sym(refvar))) %>% pull(Experiment)


batches=metadata.alldatasets.formatted %>% as.data.frame %>%
        dplyr::filter((Condition %in%  vconditions2)) %>%
        arrange(dsname) %>% group_split(dsname) %>% lapply(., function(x) x %>% pull(Experiment) %>% c(., refexpts))

lapply(batches, function(allinvitro){

      fcat("test: allinvitro computed", paste(allinvitro, collapse=","), "\n")
      
          if(length(allinvitro)>1){

      fcat("test: entering batch loop for k = ", k, "\n")
      

      # generate positives
      positives=make.class.target.list(meta3[allinvitro, , drop=F], "Condition")

      fcat("test: positives generated, length = ", length(positives), "\n")

      # subset peaks if provided
      if(!is.null(selected.peaks)){
        fcat("test: subsetting selected.peaks\n")
        dds.invitro= dds[Reduce(c, selected.peaks) ,allinvitro]
        fcat("test: dds.invitro subset done\n")
      }else{
       dds.invitro=dds[, allinvitro] 
      }
 
################################################################################
# prepare batch-wise deseq2 object
################################################################################
      
      simpleCache::simpleCache(
            paste0("deseq2_invitro_sepbatches2_id_", comparison.id, "_vs_",refcondition, "_comparedpeaks", ifelse(is.null(selected.peaks), "all", digest::digest(selected.peaks))) %>% addversion,
            {
              #fcat("test: inside simpleCache block, x = ", x, "\n")

              dds.invitro[[refvar]] <- factor(dds.invitro[[refvar]])
              design(dds.invitro) <- as.formula(paste0("~", refvar))
              fcat("test: DESeq design set\n")

              dds.invitro <- DESeq(dds.invitro)
              #fcat("test: DESeq completed for x = ", x, "\n")

              dds.invitro
            },
            assignToVar="dds.invitro", reload=T
          )

################################################################################
 # obtain all contrasts for this batch     
################################################################################

      rng=1:(length(positives))
      fcat("test: rng defined, size = ", length(rng), "\n")

      pardesbatch2=parallel::mclapply(
        rng,
        function(x, dd, allpos){
          fcat("test: mclapply iteration x = ", x, "\n")

          
          lab=names(allpos)[x]
          fcat("test: lab = ", lab, "\n")

          if(lab==refcondition){
            fcat("test: lab equals ref, returning NULL\n")
            return(NULL)
          } else {
            classvar="Condition"
            levs=c(lab, refcondition)

            res <- results(dd, contrast=c(classvar, levs[1], levs[2]))
            fcat("test: results extracted for lab = ", lab, "\n")

            return(res %>% as.data.frame %>% dplyr::mutate(id=!!comparison.id, target=lab, reference=refcondition))
          }

        },
        allpos=positives,
        dd=dds.invitro,
        mc.cores=cores,
        mc.cleanup=T
      ) %>% givename(., names(positives[rng]))

hits=lapply(pardesbatch2[vconditions2], function(x) if(!is.null(x)) x %>% arrange(padj) %>% filter(padj<=0.05) %>% names2col(., "Geneid") %>% dplyr::mutate(concordance=check.concordance(Geneid)) %>% dplyr::filter(concordance!=exclude) %>% annotate.peak.table(., annotation.peaks = annotation.peaks) %>% arrange(factor(concordance, levels=c("concordant.open", "discordant", "concordant.closed", "other"))))



```




Analyse log fold change distributions among groups with ANOVA
```{r}

dedf=all.des[vconditions2] %>% lapply(., function(x){ x = x %>% names2col(., "Geneid"); rownames(x)=NULL;x}) %>% Reduce(rbind, .)  %>% dplyr::mutate(concordance=check.concordance(Geneid)) 
smry= dedf %>% group_by(target, concordance) %>% summarise(meanfc=mean(log2FoldChange),medianfc=median(log2FoldChange), counts=n() ) %>% arrange(concordance, target)
# Ensure factors are treated as factors
dedf$target <- as.factor(dedf$target)
dedf$concordance <- as.factor(dedf$concordance)

# Run two-way ANOVA with interaction
dedf2=dedf %>% filter(concordance=="concordant.closed")
anova_model <- aov(log2FoldChange ~ target, data =dedf2 )
# View ANOVA table
summary(anova_model)
TukeyHSD(anova_model)



interaction.plot(dedf$target, dedf$concordance, dedf2$log2FoldChange)



```


Effect size density plots

```{r flag, fig.width=2.5, fig.height=2.5}
################################################################################
# plot effect size distributions facetted
################################################################################


sca=2
efp=effect.size.plot2(all.des[vconditions2], concordance.peaks=concordance.peaks.unique, thr=0, pval=Inf, padj=Inf, exclude="nothing")

tpdf("densityplot_DEvs5E", wi=pw*sca, he=pw*sca)
print(efp+coord_cartesian(xlim=c(-2,2)))
dev.off()
```





Scatterplots of DA between conditions

```{r}

tmscatter.noda=cbind.DE(all.des.individual.5E5, ref="5E_ds5") %>% names2col(., "Geneid") %>% dplyr::mutate(concordance0=check.concordance(Geneid)) %>% dplyr::mutate(concordance=ifelse(pvalue_TGFB1_ds5_vs_5E_ds5<=0.05|pvalue_TGFB2_ds5_vs_5E_ds5<=0.05,concordance0, "no DA" )) %>% dplyr::filter(concordance=="no DA")


tmscatter.da=cbind.DE(all.des.individual.5E5, ref="5E_ds5") %>% names2col(., "Geneid") %>% dplyr::mutate(concordance=check.concordance(Geneid)) %>%  dplyr::mutate(concordance=factor(concordance)) %>% dplyr::filter(pvalue_TGFB1_ds5_vs_5E_ds5<=0.05|pvalue_TGFB2_ds5_vs_5E_ds5<=0.05) %>% dplyr::filter(concordance!="other")

 xyplot(cbind.DE(, x="log2FC_TGFB1_ds5_vs_5E_ds5", y="log2FC_TGFB2_ds5_vs_5E_ds5", colorby="concordance")


  
scatter.signif.tgfb=(ggplot(tmscatter.noda, aes(x=log2FC_TGFB1_ds5_vs_5E_ds5, y=log2FC_TGFB2_ds5_vs_5E_ds5))+geom_point_rast(alpha=0.002, color="#444444")+theme_classic()+geom_point_rast(data=tmscatter.da,  aes(x=log2FC_TGFB1_ds5_vs_5E_ds5, y=log2FC_TGFB2_ds5_vs_5E_ds5, fill=concordance, alpha=0.5),size=0.9, color="black", shape=21)+scale_color_manual(values=allcolors[["concordance"]])+scale_fill_manual(values=allcolors[["concordance"]]) ) 
sca=0.9
tpdf("scatterplot_significant_tgfb", wi=pw*sca*1.7, he=pw*sca)
print(scatter.signif.tgfb)
dev.off()
              
################################################################################
#significant discordant peaks labeling
################################################################################

pld=scatter.signif.tgfb+geom_text(data=tmscatter.da %>% dplyr::filter(concordance=="discordant", abs(log2FC_TGFB1_ds5_vs_5E_ds5)>=2|abs(log2FC_TGFB2_ds5_vs_5E_ds5)>=2),  aes(x=log2FC_TGFB1_ds5_vs_5E_ds5, y=log2FC_TGFB2_ds5_vs_5E_ds5, label=Geneid), size=4) 
sca=3
tpdf("scatterplot_significant_tgfb_labeled_discordant", wi=pw*sca*1.7, he=pw*sca)
print(pld)
dev.off()
              
        
################################################################################
#significant concordant peaks labeling
################################################################################

plc=scatter.signif.tgfb+geom_text(data=tmscatter.da %>% dplyr::filter(concordance=="concordant.closed", abs(log2FC_TGFB1_ds5_vs_5E_ds5)>=2|abs(log2FC_TGFB2_ds5_vs_5E_ds5)>=2),  aes(x=log2FC_TGFB1_ds5_vs_5E_ds5, y=log2FC_TGFB2_ds5_vs_5E_ds5, label=Geneid), size=4)        
sca=3
tpdf("scatterplot_significant_tgfb_labeled_concordantclosed", wi=pw*sca*1.7, he=pw*sca)
print(plc)
dev.off()    


plo=scatter.signif.tgfb+geom_text(data=tmscatter.da %>% dplyr::filter(concordance=="concordant.open", abs(log2FC_TGFB1_ds5_vs_5E_ds5)>=0.5|abs(log2FC_TGFB2_ds5_vs_5E_ds5)>=0.5),  aes(x=log2FC_TGFB1_ds5_vs_5E_ds5, y=log2FC_TGFB2_ds5_vs_5E_ds5, label=Geneid), size=4)        
sca=3
tpdf("scatterplot_significant_tgfb_labeled_concordantopen", wi=pw*sca*1.7, he=pw*sca)
print(plo)
dev.off()   


significant.tgfb1.scatter=tmscatter.da %>% dplyr::filter( abs(log2FC_TGFB1_ds5_vs_5E_ds5)>=2|abs(log2FC_TGFB2_ds5_vs_5E_ds5)>=2) %>% dplyr::select(Geneid, concordance,log2FC_TGFB1_ds5_vs_5E_ds5, log2FC_TGFB2_ds5_vs_5E_ds5 , pvalue_TGFB2_ds5_vs_5E_ds5,  pvalue_TGFB1_ds5_vs_5E_ds5) %>% arrange(concordance) %>% filter(concordance!="other") 

signif.info.bed=annotation.peaks[(annotation.peaks$Geneid %in% significant.tgfb1.scatter$Geneid), ] %>% bind_cols(., significant.tgfb1.scatter %>% select(-Geneid)) %>% select(c(2:4))

signif.info=annotation.peaks[(annotation.peaks$Geneid %in% significant.tgfb1.scatter$Geneid), ] %>% bind_cols(., significant.tgfb1.scatter %>% select(-Geneid))

dump.table(signif.info)
dump.table(signif.info.bed)



```



barplots showing qualities of DE peaks vs reference

```{r}
sca=.5
all.des=Reduce(c, all.des.individual.ery)
lst.v=targeted.changes.analysis(all.des[vconditions], mw$concordance.peaks, pval=1, thr=0, facet="type")

bg=ggplot(lst.v$df %>% group_by(treatment, effect, concordance) %>% summarise(counts=n()), aes(x=treatment, y=counts, fill=concordance))+geom_col()+ggtitle("# DE vs Ery, separate batches +Ery")


bd=ggplot(lst.v$df %>% group_by(treatment, effect, concordance) %>% summarise(counts=n())  %>% filter(concordance=="discordant"), aes(x=treatment, y=counts, fill=concordance))+geom_col()

bco=ggplot(lst.v$df %>% group_by(treatment, effect, concordance) %>% summarise(counts=n())  %>% filter(concordance=="concordant.open"), aes(x=treatment, y=counts, fill=concordance))+geom_col()

bcc=ggplot(lst.v$df %>% group_by(treatment, effect, concordance) %>% summarise(counts=n())  %>% filter(concordance=="concordant.closed"), aes(x=treatment, y=counts, fill=concordance))+geom_col()

#########
# dataframe comparing the logfoldchanges of one peak vs ery across treatments
#########


simplebars=ggplot(lst.v$df %>% group_by(treatment, effect, concordance) %>% summarise(counts=n()), aes(x=treatment, y=counts, fill=concordance))+geom_col()+theme_minimal()
tpdf("simplebars", wi=pw*sca*1.5, he=pw*sca*.8)
print(simplebars)
dev.off()

simplebars=ggplot(lst.v$df  %>% dplyr::filter(treatment %in% vconditions) %>% group_by(treatment, effect, concordance) %>% summarise(counts=n()), aes(x=treatment, y=counts, fill=concordance))+geom_col()+theme_minimal()
tpdf("simplebars", wi=pw*sca*1.5, he=pw*sca*.8)
print(simplebars)
dev.off()
```

Barplots of open and close peaks above a threshold

```{r}
#conditions to benchmark during the validation
pconditions=c("Ery", "5E_ds5","IL41_ds5", "IL42_ds5", "TGFB1_ds5", "TGFB2_ds5")
meta4=metadata.alldatasets.formatted
samples.to.plot=meta4 %>% dplyr::filter(Condition %in% pconditions) %>% arrange(factor(Condition, levels=pconditions)) %>% pull(Experiment)


vsdlist=lapply(concordance.peaks.unique, function(pp){
vsd[unique(pp), samples.to.plot]
})

#lapply(vsdlist, function(vsd){
#(vsd>=open.thresh) %>% table  %>% t %>% as.data.frame %>% dplyr::mutate(sample=colnames(vsd)[xx], concordance=names(concordance.peaks.unique)[pp]) %>% givecolnames(., ind=2, nms="open") %>% dplyr::select(sample, concordance, open, Freq)

#cpuv= Reduce(c, concordance.peaks.unique) 
#cpuv=cpuv[!duplicated(cpuv)]


counts.concordance=counts.filtered[cpuv,  meta4 %>% dplyr::filter(Condition %in% vconditions) %>% arrange(factor(Condition, levels=pconditions)) %>% pull(Experiment)]



counts.concordance.peaksplits=lapply(concordance.peaks.unique, function(pp){
  
pctiles.concordance=lapply(1:ncol(counts.concordance), function(x) transform.to.percentiles(counts.concordance[pp,x])) %>% bind_cols %>% as.data.frame  %>% giverownames(., nms=pp) %>% 
  givecolnames(., nms = colnames(counts.concordance))
})

################################################################################
# open and closed peaks vsd
################################################################################
sca=1.5


lapply(seq(0.5,5,0.5), function(open.thresh){
dff=lapply(1:length(vsdlist), function(nn){
vsd2=(vsdlist[[nn]]>=open.thresh)
  
  
lapply(1:ncol(vsd2), function(xx){ vsd2[,xx] %>% table  %>% t %>% as.data.frame %>% dplyr::mutate(sample=colnames(vsd2)[xx], concordance=names(vsdlist)[[nn]]) %>% givecolnames(., ind=2, nms="open") %>% dplyr::select(sample, concordance, open, Freq)

}) %>% Reduce(rbind, .)
}) %>% Reduce(rbind, .)


 open.plot.vsd=ggplot(dff, aes(x=factor(sample, levels=samples.to.plot),y=Freq,fill=open))+geom_col()+facet_wrap(~factor(concordance, levels=c("concordant.open", "discordant", "concordant.closed")), nrow=3, scale="free_y")+theme_classic()+theme(axis.text.x = element_text(angle = 0,hjust = 1,vjust = .5))+rotatex(90)+scale_fill_manual(values=c("TRUE"="#00CC00", "FALSE"="#CC00CC"))+ggtitle(paste0("vsd threshold ", open.thresh))
 
 tpdf(paste0("barplot_openpeaks_concordance_vsd_thresh___", open.thresh), wi=pw*sca*1.5, he=pw*sca*1.8)
 print(open.plot.vsd)
 dev.off()
})

```

Heatmap of peaks per concordance block above a percentile(per experiment) to see if a peak changed percentile substantially from one treatment to another


```{r}
pthresh=0.3


conditions.to.plot=meta4 %>% dplyr::filter(Condition %in% pconditions) %>% arrange(factor(Condition, levels=pconditions)) %>% pull(Condition)

gaps.col=conditions.to.plot %>% factor %>% as.integer %>% diff %>% as.logical %>% which
#############################percentiles on vsd per peak group


vsd.pctile.peaksplits=lapply(1:length(vsdlist), function(nn){
vsd2=vsdlist[[nn]]  
if(length(rownames(vsd2)) != length(unique(rownames(vsd2)))){
 fcat("problem with", names(vsdlist)[[nn]]) 
  
}

# transform each column of the matrix into percentile values
vsdp=make.pctile.columns(vsd2) %>% filter.matrix.higher(., pthresh) %>% seriaterows(., reverse=T)

}) %>% givename(., names(vsdlist)[1:length(vsdlist)])

vsd.pctiles= vsd.pctile.peaksplits %>% Reduce(rbind, .)

gaps.row= lapply(vsd.pctile.peaksplits, function(x) nrow(x)) %>% Reduce(c,.) %>% cumsum




vsd.concordance.pctile.full=vsdlist %>% Reduce(rbind, .) %>% make.pctile.columns %>% filter.matrix.higher(., pthresh)
hmpfull=simple.heatmap(vsd.concordance.pctile.full, gaps_col=gaps.col, gaps_row=oneless(gaps.row))
tpdf(paste0("heatmap_vsd_percentilesfullmatrix_allconcordancepeaks_filtered_pthresh", pthresh), he=pw*sca*2, wi=pw*sca*1.2)
 print(hmpfull)
 dev.off()

################################################################################
#split after percentile calculation to seriate blocks individually
################################################################################
 srr=list(concordant.open=T, discordant=F, concordant.closed=T)
 vsd.fullpctile.blockseriated=lapply(names(vsdlist), function(x) vsd.concordance.pctile.full[rownames(vsdlist[[x]]), , drop=F] %>% seriaterows(., reverse=srr[[x]]) ) %>% Reduce(rbind, .)
 
 hmpfullbs=simple.heatmap(vsd.fullpctile.blockseriated, gaps_row=oneless(gaps.row), gaps_col=gaps.col, show_rownames=F)
tpdf(paste0("heatmap_vsd_percentilesfullmatrix_blockseriated_allconcordancepeaks_filtered_pthresh", pthresh), he=pw*sca*2, wi=pw*sca*1.2)
 print(hmpfullbs)
 dev.off()
 
 
hmp=simple.heatmap(vsd.pctiles, gaps_col=gaps.col, gaps_row=oneless(gaps.row))
tpdf(paste0("heatmap_vsd_percentiles_allconcordancepeaks_filtered_pthresh", pthresh), he=pw*sca*2, wi=pw*sca*1.2)
 print(hmp)
 dev.off()

hmp=simple.heatmap(vsd.pctile.peaksplits$discordant, gaps_col=gaps.col)
tpdf(paste0("heatmap_vsd_percentiles_discordant_filtered_pthresh", pthresh), he=pw*sca*2, wi=pw*sca*1.2)
 print(hmp)
 dev.off()

hmp=simple.heatmap(vsd.pctile.peaksplits$discordant, gaps_col=gaps.col)
tpdf(paste0("heatmap_vsd_percentiles_discordant_filtered_pthresh", pthresh), he=pw*sca*2, wi=pw*sca*1.2)
 print(hmp)
 dev.off()

hmp=simple.heatmap(vsd.pctile.peaksplits$concordant.open, gaps_col=gaps.col)
tpdf(paste0("heatmap_vsd_percentiles_concordantopen_filtered_pthresh", pthresh), he=pw*sca*2, wi=pw*sca*1.2)
 print(hmp)
 dev.off()

hmp=simple.heatmap(vsd.pctile.peaksplits$concordant.closed, gaps_col=gaps.col)
tpdf(paste0("heatmap_vsd_percentiles_concordantclosed_filtered_pthresh", pthresh), he=pw*sca*2, wi=pw*sca*1.2)
 print(hmp)
 dev.off()



pctiles.concordance=lapply(1:ncol(counts.concordance), function(x) transform.to.percentiles(counts.concordance[cpuv,x])) %>% bind_cols %>% as.data.frame  %>% giverownames(., nms=cpuv) %>% 
  givecolnames(., nms = colnames(counts.concordance))



hmc=row.heatmap(counts.concordance)


lapply(seq(0.1, 0.6, 0.1), function(pthresh){
pctiles.filtered=apply(vsd.pctiles, c(1,2), function(x) ifelse(x>=pthresh, x, 0)) #%>% seriaterows(., reverse=T)
pctiles.filtered.forward=apply(vsd.pctiles, c(1,2), function(x) ifelse(x>=pthresh, x, 0)) #%>% seriaterows(., reverse=F)

hmpf=simple.heatmap(pctiles.filtered, gaps_col=gaps.col, show_rownames=F, main=paste0("percentile threshold=", pthresh))
hmpfo=simple.heatmap(pctiles.filtered.forward, gaps_col=gaps.col, show_rownames=F, main=paste0("percentile threshold=", pthresh))

tpdf(paste0("heatmap_pctiles_concordance_validation_filtered_thresh_", pthresh, "_seriatedreverse"), he=pw*sca*2, wi=pw*sca*1.2)
 print(hmpf)
 dev.off()
 
 tpdf(paste0("heatmap_pctiles_concordance_validation_filtered_thresh_", pthresh, "_seriatedforward"), he=pw*sca*2, wi=pw*sca*1.2)
 print(hmpfo)
 dev.off()
})





tpdf(paste0("heatmap_counts_concordance_validation_filtered"), he=pw*sca*2, wi=pw*sca*1.2)
 print(hmc)
 dev.off()
 

open.thresh=1 
hmv=simple.heatmap(Reduce(rbind, vsdlist) >= open.thresh, col=c( "#CC00CC", "#00CC00"), gaps_col=gaps.col,gaps_row=oneless(gaps.row), show_rownames=F)

tpdf(paste0("heatmap_vsd_concordance_validation_filtered_openthresh_", open.thresh), he=pw*sca*2, wi=pw*sca*1.2)
 print(hmv)
 dev.off()

```



```{r flag}
# collecting all log fold changes
cbind.DE=function(all.des.list, ref=config$target_cell_type, vconditions=NULL){

all.des=Reduce(c, all.des.list)
if(is.null(vconditions)){
 vconditions=names(all.des) 
}
pks=rownames(all.des[[1]])

pdetab=lapply(vconditions %>% removegene(ref), function(x){
  fcat(x)
lfc=paste_("log2FC",x,"vs", ref)
bm=paste_("basemean",x,"vs", ref)
pv=paste_("pvalue",x,"vs",ref)  

  (all.des[[x]] %>% dplyr::mutate(!!sym(lfc):= log2FoldChange, !!sym(bm):= baseMean, !!sym(pv):= pvalue) %>% select(!!sym(bm), !!sym(lfc), !!sym(pv) )
  )[pks, , drop=F]  
  
  }) %>% Reduce(cbind, .)


pdetab


}

all.pde.tables=list(cbind.DE(all.des.individual.5E3, ref="5E_ds3"), cbind.DE(all.des.individual.5E5, ref="5E_ds5"), cbind.DE(all.des.individual.ery, ref="Ery")) %>% Reduce(cbind, .)
all.pde.tables=all.pde.tables %>% names2col(., "Geneid") %>% dplyr::mutate(concordance=find.membership(Geneid, !!concordance.peaks.unique)) %>% dplyr::filter(concordance %in% names(concordance.peaks.unique))
```





```{r}
bg=ggplot(lst.v$df %>% group_by(treatment, effect, concordance) %>% summarise(counts=n()), aes(x=treatment, y=counts, fill=concordance))+geom_col()+ggtitle("# DE vs Ery, separate batches +Ery")



bd=ggplot(lst.v$df %>% group_by(treatment, effect, concordance) %>% summarise(counts=n())  %>% filter(concordance=="discordant"), aes(x=treatment, y=counts, fill=concordance))+geom_col()

bco=ggplot(lst.v$df %>% group_by(treatment, effect, concordance) %>% summarise(counts=n())  %>% filter(concordance=="concordant.open"), aes(x=treatment, y=counts, fill=concordance))+geom_col()

bcc=ggplot(lst.v$df %>% group_by(treatment, effect, concordance) %>% summarise(counts=n())  %>% filter(concordance=="concordant.closed"), aes(x=treatment, y=counts, fill=concordance))+geom_col()

#########
# dataframe comparing the logfoldchanges of one peak vs ery across treatments
#########


simplebars=ggplot(lst.v$df  %>% dplyr::filter(grepl("v$", treatment)) %>% group_by(treatment, effect, concordance) %>% summarise(counts=n()), aes(x=treatment, y=counts, fill=concordance))+geom_col()+theme_minimal()
tpdf("simplebars", wi=pw*sca*1.5, he=pw*sca*.8)
print(simplebars)
dev.off()

simplebars=ggplot(lst.v$df  %>% dplyr::filter(treatment %in% vconditions) %>% group_by(treatment, effect, concordance) %>% summarise(counts=n()), aes(x=treatment, y=counts, fill=concordance))+geom_col()+theme_minimal()
tpdf("simplebars", wi=pw*sca*1.5, he=pw*sca*.8)
print(simplebars)
dev.off()

```



Alluvial plots showing DE status change of each peak versus a reference in each condition
```{r}
################################################################################
# revisited code transferplots
################################################################################
bin.DE3 <- function(x) {
  if(class(x)!="numeric"){
  x
    }else{
    
  cut(na2zero(x),
      breaks = c(-Inf,-.5, .5, Inf),
      labels = c("more closed", "no DA", "more open"),
      right = FALSE, include.lowest = TRUE)
    }
}


DE.among.conditions=lst.v$df %>% dplyr::filter(Geneid %in% all.pde.tables$Geneid) %>% pivot_wider(., names_from="treatment", values_from="log2FoldChange", id_cols=c("Geneid", "concordance")) %>% arrange(`5E_ds3`)



binned.dac3=apply(DE.among.conditions[, 3:ncol(DE.among.conditions)], c(1,2), function(x) bin.DE3(as.numeric(x))) %>% cbind(DE.among.conditions[,c(1:2)], .) %>% as.data.frame



### filtering the peaks to those where there is no difference between 5E d3 and 5E d5
tp3=transferplot(df=binned.dac3 %>% dplyr::filter(!!sym("5E_ds3")=="no DA" ), labelvars=colnames(binned.dac3)[c(2, 4, 8,7,6,9)]  , )+theme_clean_minimal()+xlab("")+ylab("Frequency")

### filtering to only discordant peaks
tp4=transferplot(df=binned.dac3 %>% dplyr::filter(!!sym("5E_ds3")=="no DA" ), labelvars=colnames(binned.dac3)[c(4, 8,7,6,9)], facetvar = "concordance", facet.nrow=3, facet.ncol=1)+theme_clean_minimal()+xlab("")+ylab("Frequency")


colls=c(4, 8,7,6,9)
alluvial.list=lapply(colls, function(cc){
tp=transferplot(df=binned.dac3 %>% dplyr::filter(!!sym("5E_ds3")== "no DA"), labelvars=colnames(binned.dac3)[c(2, cc )]  , )+theme_clean_minimal()+xlab("")+ylab("Frequency")+NoLegend()
})


alluvial.list %>% Reduce('+', .)




ggplot(alldeinfo.concordance %>% filter(pvalue_TGFB2_ds5_vs_5E_ds5 <= 0.05 | pvalue_TGFB1_ds5_vs_5E_ds5 <= 0.05 | pvalue_IL41_ds5_vs_5E_ds5 <= 0.05 | pvalue_IL42_ds5_vs_5E_ds5 <= 0.05) %>% pivot_longer(., cols=c("log2FC_TGFB2_ds5_vs_5E_ds5", "log2FC_TGFB1_ds5_vs_5E_ds5", "log2FC_IL41_ds5_vs_5E_ds5", "log2FC_IL42_ds5_vs_5E_ds5" ), names_to="comparison", values_to="logfc"),
       aes(x=comparison, y=logfc, fill=concordance))+geom_violin(position="")

```



```{r flag}
################################################################################
# find differences to several other conditions
################################################################################




simpleCache("all_fold_changes_multiref" %>% addversion, {

fold.changes.multiref=lapply(refconditions, function(refcondition){

  
  fcat("calculating de vs", refcondition)
simpleCache(paste0("all_DE_invitro_vs_", refcondition) %>% addversion, {
all.des=de.matches.invitro.workflow.sepbatches(envlist=list(dds=dds[, rownames(meta.test)], dataset.info=dataset.info, meta2=meta.test, selected.peaks=mw$concordance.peaks.unique %>% Reduce(c, .)), reload=F, ref=refcondition, refvar="Condition", cores=1, comparison.id=paste0("vs",refcondition, "_allandconcordant_perbatch"))
}, assignToVar="all.des", recreate=T)
all.des
}) %>% givename(., refconditions)

fold.changes.multiref
}, assignToVar="fold.changes.multiref", reload=T )


################################################################################
# same as above but using sepbatches2 which should be improved
################################################################################

refconditions=c("5E_d5")
fold.changes.multiref2=lapply(refconditions, function(refcondition){
  
meta.test=metadata.alldatasets.formatted %>% dplyr::filter(Condition %in% c(refcondition, vconditions2))
  fcat("calculating de vs", refcondition)
#simpleCache(paste0("all_DE_invitro_vs_", refcondition) %>% addversion, {
all.des.batch=de.matches.invitro.workflow.sepbatches2(envlist=list(dds=dds[, rownames(meta.test)], dataset.info=dataset.info, meta2=meta.test, selected.peaks=concordance.peaks.unique %>% Reduce(c, .)), reload=F, ref=refcondition, refvar="Condition", cores=1, comparison.id=paste0("vs",refcondition, "_allandconcordant_perbatch"))
#}, assignToVar="all.des", recreate=T)
all.des
}) %>% givename(., refconditions)

fold.changes.multiref
}, assignToVar="fold.changes.multiref2", reload=T )


################################################################################
# compile data of comparisons and plot
################################################################################


simpleCache("all_invitro_comparisons_df_different_peak_sets" %>% addversion, {
allcomps=list()

for(typ in ("all peaks", "selected peaks")){
allcomps[[typ]]=lapply(names(fold.changes.multiref), function(refcondition){
  

## concatenating all batches for ease.    
all.descat=Reduce(c, fold.changes.multiref[[refcondition]][[typ]])
#names(all.descat)=gsub("_ds[0-9]", "", names(all.descat))

# collecting all log fold changes


pdetab=lapply(c("TGFB1_ds5", "TGFB2_ds5", "8G_ds3", "8G_ds5", "5E_ds3", "5E_ds5" ), function(x){
lfc=paste_("log2FC",x,"vs", refcondition)
bm=paste_("basemean",x,"vs", refcondition)
pv=paste_("pvalue",x,"vs",refcondition)

fcat(lfc)
all.descat[[x]] %>% dplyr::mutate(!!sym(lfc):= log2FoldChange, !!sym(bm):= baseMean, !!sym(pv):= pvalue) %>% select(!!sym(bm), !!sym(lfc), !!sym(pv) )
}) %>% bind_cols()
pdetab

  
}) %>% givename(., refconditions)  
}
allcomps
}, assignToVar="allcomps", reload=T)

pan=lapply(c("TGFB1_ds5", "TGFB2_ds5", "8G_ds3", "8G_ds5" ), function(x){
  refcondition1="5E_d5"
  refcondition2="Ery" 
  
  lfc1=paste_("log2FC",x,"vs", refcondition1)
  lfc2=paste_("log2FC",x,"vs", refcondition2)
bm=paste_("basemean",x,"vs", refcondition2)
pv=paste_("pvalue",x,"vs",refcondition2)
allcomps[[typ]] %>% bind_cols %>% ggplot(., aes(x=!!sym(lfc1), y=!!sym(lfc2), color=!!sym(bm)))+geom_point(alpha=0.5)+ggtitle(paste(x, typ))+coord_cartesian(xlim=c(-4, 4), ylim=c(-4, 4))+theme_minimal()+scale_color_viridis_c(limits = c(0, 300), oob = scales::squish)


}) %>% Reduce("+", .)



prs=list(c("TGFB1_ds5", "5E_ds5") %>% rev,
                   c("TGFB2_ds5", "5E_ds5") %>% rev,
                   c("TGFB1_ds5", "5E_ds3") %>% rev,
                   c("TGFB2_ds5", "5E_ds3") %>% rev,
                   c("5E_ds3", "5E_ds5"),
                   c("8G_ds3", "8G_ds5") 
                    
                   )


pantar=lapply(prs, function(x){
  
  targetcondition1=x[1]
  targetcondition2=x[2] 
  refcondition="Ery"
  
  lfc1=paste_("log2FC",x[1],"vs", refcondition)
  lfc2=paste_("log2FC",x[2],"vs", refcondition)
bm=paste_("basemean",x[1],"vs", refcondition)
pv1=paste_("pvalue",x[1],"vs",refcondition)
df=allcomps[[typ]] %>% bind_cols

ggplot(df, aes(x=!!sym(lfc1), y=!!sym(lfc2), color=!!sym(bm)))+geom_point(alpha=0.5)+coord_cartesian(xlim=c(-4, 4), ylim=c(-4, 4))+theme_minimal()+scale_color_viridis_c(limits = c(0, 50), oob = scales::squish)


}) %>% Reduce("+", .)



lst.v=targeted.changes.analysis(all.descat[c("8G","5E", "8Gv","5Ev", "TGFB1v","TGFB2v","IL41v","IL42v")], concordance.peaks, pval=0.05, thr=1, facet="type")



masks= lapply(chosen.condition5, function(x){
deepdata$matts$Geneid %in% (lst.v$df %>% dplyr::filter(treatment==x, abs(log2FoldChange)>=1) %>% pull(Geneid))
})

################################################################################
# modify Ery mask to visualise it
################################################################################

masks[[1]]= !masks[[1]]

nsamples=length(dtp$all.bigwigs)

matts=deepdata$matts
matth=deepdata$matth
cols.per.sample=ncol(matth)/nsamples


samples.to.plot=meta4 %>% dplyr::filter(Condition %in% chosen.condition5) %>% arrange(factor(Condition, levels=chosen.condition5)) %>% pull(Experiment)
conditions.to.plot=meta4 %>% dplyr::filter(Condition %in% vconditions) %>% arrange(factor(Condition, levels=vconditions)) %>% pull(Condition)
gaps.col=conditions.to.plot %>% factor %>% as.integer %>% diff %>% as.logical %>% which
gaps.row=factor(matts[, "deepTools_group"]) %>% as.integer %>% diff %>% as.logical %>% which



coords.and.annot=lapply(1:length(chosen.condition5), function(j){
samplecoords=get.sample.coords(j, extend.from.center=100, cols.per.sample=cols.per.sample)
annot=samplecoords %>% as.data.frame %>% dplyr::mutate(sample=chosen.condition5[j]) %>% dplyr::select(sample)
list(coords=samplecoords, annot=annot)
})

simpleCache("full_peaks_annot" %>% addversion, {
full.peaks.annot=lapply(coords.and.annot, function(x) x$annot) %>% Reduce(rbind, .)
gaps.col.peaks=full.peaks.annot$sample %>% factor %>% as.integer %>% diff %>% as.logical %>% which
full.samplecoords=lapply(coords.and.annot, function(x) x$coords) %>% Reduce(c, .)
list(full.peaks.annot=full.peaks.annot, gaps.col.peaks=gaps.col.peaks, full.samplecoords=full.samplecoords)
}, assignToVar="matrix.plot.annot", recreate=T)

hvm=simple.heatmap((matth %>% giverownames(., rownames(matts)))[rownames(vsd.concordance), full.samplecoords],col=brewer.pal(n=5, name = "RdBu"), gaps_col=gaps.col.peaks)




tpdf("heatmap_deeptoolsregions_masked", wi=pw*sca*5, he=pw*sca*2)
print(hvm)
dev.off()

simpleCache("vsd.concordance" %>% addversion, {
vsd.concordance=vsd[intersect(rownames(matts), rownames(vsd)), samples.to.plot ]
vsd.concordance
}, assignToVar="vsd.concordance", reload=T)


#############################percentiles on vsd per peak group
pthresh=0.6

vsd.pctile.peaksplits=lapply(1:length(vsdlist), function(nn){
vsd2=vsdlist[[nn]]  
if(length(rownames(vsd2)) != length(unique(rownames(vsd2)))){
 fcat("problem with", names(vsdlist)[[nn]]) 
  
}

# transform each column of the matrix into percentile values
vsdp=make.pctile.columns(vsd2) %>% filter.matrix.higher(., pthresh) %>% seriaterows(., reverse=T)

}) %>% givename(., names(vsdlist)[1:length(vsdlist)])

vsd.pctiles= vsd.pctile.peaksplits %>% Reduce(rbind, .)

gaps.row= lapply(vsd.pctile.peaksplits, function(x) nrow(x)) %>% Reduce(c,.) %>% cumsum


pthresh=0.4
vsd.concordance.pctile.full=vsdlist %>% Reduce(rbind, .) %>% make.pctile.columns %>% filter.matrix.higher(., pthresh)
hmpfull=simple.heatmap(vsd.concordance.pctile.full, gaps_col=gaps.col, gaps_row=oneless(gaps.row))
tpdf(paste0("heatmap_vsd_percentilesfullmatrix_allconcordancepeaks_filtered_pthresh", pthresh), he=pw*sca*2, wi=pw*sca*1.2)
 print(hmpfull)
 dev.off()

################################################################################
#split after percentile calculation to seriate blocks individually
################################################################################
 srr=list(concordant.open=T, discordant=F, concordant.closed=T)
 vsd.fullpctile.blockseriated=lapply(names(vsdlist), function(x) vsd.concordance.pctile.full[rownames(vsdlist[[x]]), , drop=F] %>% seriaterows(., reverse=srr[[x]]) ) %>% Reduce(rbind, .)
 
 hmpfullbs=simple.heatmap(vsd.fullpctile.blockseriated, gaps_col=gaps.col, gaps_row=oneless(gaps.row))
tpdf(paste0("heatmap_vsd_percentilesfullmatrix_blockseriated_allconcordancepeaks_filtered_pthresh", pthresh), he=pw*sca*2, wi=pw*sca*1.2)
 print(hmpfullbs)
 dev.off()
 
 
hmp=simple.heatmap(vsd.pctiles, gaps_col=gaps.col, gaps_row=oneless(gaps.row))
tpdf(paste0("heatmap_vsd_percentiles_allconcordancepeaks_filtered_pthresh", pthresh), he=pw*sca*2, wi=pw*sca*1.2)
 print(hmp)
 dev.off()

hmp=simple.heatmap(vsd.pctile.peaksplits$discordant, gaps_col=gaps.col)
tpdf(paste0("heatmap_vsd_percentiles_discordant_filtered_pthresh", pthresh), he=pw*sca*2, wi=pw*sca*1.2)
 print(hmp)
 dev.off()

hmp=simple.heatmap(vsd.pctile.peaksplits$discordant, gaps_col=gaps.col)
tpdf(paste0("heatmap_vsd_percentiles_discordant_filtered_pthresh", pthresh), he=pw*sca*2, wi=pw*sca*1.2)
 print(hmp)
 dev.off()

hmp=simple.heatmap(vsd.pctile.peaksplits$concordant.open, gaps_col=gaps.col)
tpdf(paste0("heatmap_vsd_percentiles_concordantopen_filtered_pthresh", pthresh), he=pw*sca*2, wi=pw*sca*1.2)
 print(hmp)
 dev.off()

hmp=simple.heatmap(vsd.pctile.peaksplits$concordant.closed, gaps_col=gaps.col)
tpdf(paste0("heatmap_vsd_percentiles_concordantclosed_filtered_pthresh", pthresh), he=pw*sca*2, wi=pw*sca*1.2)
 print(hmp)
 dev.off()



pctiles.concordance=lapply(1:ncol(counts.concordance), function(x) transform.to.percentiles(counts.concordance[cpuv,x])) %>% bind_cols %>% as.data.frame  %>% giverownames(., nms=cpuv) %>% 
  givecolnames(., nms = colnames(counts.concordance))




lapply(seq(0.1, 0.6, 0.1), function(pthresh){
pctiles.filtered=apply(vsd.pctiles, c(1,2), function(x) ifelse(x>=pthresh, x, 0)) #%>% seriaterows(., reverse=T)
pctiles.filtered.forward=apply(vsd.pctiles, c(1,2), function(x) ifelse(x>=pthresh, x, 0)) #%>% seriaterows(., reverse=F)

hmpf=simple.heatmap(pctiles.filtered, gaps_col=gaps.col, show_rownames=F, main=paste0("percentile threshold=", pthresh))
hmpfo=simple.heatmap(pctiles.filtered.forward, gaps_col=gaps.col, show_rownames=F, main=paste0("percentile threshold=", pthresh))

tpdf(paste0("heatmap_pctiles_concordance_validation_filtered_thresh_", pthresh, "_seriatedreverse"), he=pw*sca*2, wi=pw*sca*1.2)
 print(hmpf)
 dev.off()
 
 tpdf(paste0("heatmap_pctiles_concordance_validation_filtered_thresh_", pthresh, "_seriatedforward"), he=pw*sca*2, wi=pw*sca*1.2)
 print(hmpfo)
 dev.off()
})





tpdf(paste0("heatmap_counts_concordance_validation_filtered"), he=pw*sca*2, wi=pw*sca*1.2)
 print(hmc)
 dev.off()
 

open.thresh=1 
hmv=simple.heatmap(Reduce(rbind, vsdlist) >= open.thresh, col=c( "#CC00CC", "#00CC00"), gaps_col=gaps.col,gaps_row=oneless(gaps.row), show_rownames=F)

tpdf(paste0("heatmap_vsd_concordance_validation_filtered_openthresh_", open.thresh), he=pw*sca*2, wi=pw*sca*1.2)
 print(hmv)
 dev.off()







hmpf=simple.heatmap(pctiles.concordance.filtered, gaps_col=gaps.col, show_rownames=F, main=paste0("percentile threshold=", pthresh))
hmpfo=simple.heatmap(pctiles.concordance.filtered.forward, gaps_col=gaps.col, show_rownames=F, main=paste0("percentile threshold=", pthresh))

tpdf(paste0("heatmap_pctiles_concordance_validation_filtered_thresh_", pthresh, "_seriatedreverse"), he=pw*sca*2, wi=pw*sca*1.2)
 print(hmpf)
 dev.off()
 
 tpdf(paste0("heatmap_pctiles_concordance_validation_filtered_thresh_", pthresh, "_seriatedforward"), he=pw*sca*2, wi=pw*sca*1.2)
 print(hmpfo)
 dev.off()
})
 
special.label=NULL
hmats=lapply(1:length(masks), function(j) {
  
  if(j <= length(masks)){
  mask=masks[[j]]
  }else{
  mask= rep(T, nrow(matth))
  }
  
  pmat=matth[,get.sample.coords(j, extend.from.center=100, cols.per.sample = cols.per.sample)]
  
  
  special.labelf<- rep("", ncol(pmat))
    special.labelf[round(cols.per.sample/2)]=chosen.condition5[j]
    special.label<<-c(special.label, special.labelf)
  pmat[!mask,]=NA
  pmat
})

gaps.col= lapply(hmats, function(x) ncol(x)) %>% Reduce(c, .) %>% cumsum
gaps.col= gaps.col[1:(length(gaps.col)-1)]

hmats=hmats %>% bind_cols 

hm=ComplexHeatmap::pheatmap(hmats, scale="none", cluster_row=F, cluster_col=F, breaks=seq(0,3,.02), gaps_row=gaps.row, gaps_col=gaps.col, annotation_row=matts[, "deepTools_group", drop=F], color=brewer.pal(n=11, name = "RdBu"), na_col="#888888", use_raster=T, labels_col= )



tpdf("heatmap_read_deeptools_masked1", wi=pw*sca*5, he=pw*sca*3)
print(hm)
dev.off()




dds.c=subset.and.process.dds(dds, peaks=concordance.peaks %>% Reduce(c, .), samples=testids, meta=meta2, varr="rbc.combo" )


simpleCache("motifs_workspace" %>% addversion,{
  package.vars(concordance.peaks, concordance.peaks.unique, mtf_mat_gathered, lst.v, closest_tss_global, meta3, meta4, testids)
  
  }, assignToVar="motifs.workspace", reload=T )

simpleCache("motifs_workspace_lean" %>% addversion,{
  motifs.workspace$mtf_mat_gathered=NULL
  motifs.workspace
  }, assignToVar="mw", reload=T )


mw=transfer.cache.direct("motifs_workspace", previous.version= "20240925.broad")



##gathering the motifs present at each  peak (concordance peaks)
```

MOTIF ANALYSIS. Concordance peaks
```{r flag}
allcolors[["concordance"]]=c("#F8766D", "#00BA38", "#619CFF") %>% givename(., c("concordant.closed", "concordant.open", "discordant"))
tfs=c("STAT1", "STAT2", "IRF2", "IRF8", "FOXG1", "ERG", "FLI1", "ETS2", "CPEB1", "OVOL2", "HXA9", "SOX5", "PROP1", "SOX15", "HXD12", "HXD11", "UNC4", "DLX3", "FOXJ3", "ZFP82", "ANDR", "NFAC1", "PRDM6", "ARI3A", "IRF3", "RUNX1", "RUNX3", "MNX1", "BC11A", "ZN394", "ZN713", "HXA11", "PO3F4", "GATA5", "MNX1", "LMX1B", "ONEC2", "PO3F3","FOXD2", "IRF7", "SMCA1", "NFAC2", "PEBB", "EHF" ) %>% unique

pks=intersect( rownames(mw$mtf_mat_gathered), all.pde.tables$Geneid)

selGeneAnnot=prepare.motif.annotation.materials()
closest_tss_concordance=geneAssignmentStrategies$closest_tss(GRanges(annotation.peaks[pks, ]), gene_annot=selGeneAnnot, window_size=Inf)

alldeinfo.concordance=list(annotation.peaks[pks, ] , closest.tss.all[pks,, drop=F  ] %>% select(-Geneid), mw$mtf_mat_gathered[pks, tfs, drop=F], all.pde.tables[pks, , drop=F] %>% select(-Geneid) ) %>% Reduce(cbind, .) 


ggplot(alldeinfo.concordance %>% dplyr::filter( pvalue_TGFB1_ds5_vs_5E_ds5<=0.05), aes(x=log2FC_TGFB1_ds5_vs_5E_ds5, y=log2FC_TGFB2_ds5_vs_5E_ds5))+geom_point(aes(color=concordance))+facet_wrap(~concordance)  
  
(ggplot( alldeinfo.concordance %>% dplyr::filter(pvalue_TGFB1_ds5_vs_5E_ds5 <= 0.05),aes(x = log2FC_TGFB1_ds5_vs_5E_ds5,  y = log2FC_TGFB2_ds5_vs_5E_ds5, factor = factor(STAT2), colour = factor(STAT2)))+geom_point()+facet_wrap(~concordance)) %>% ggMarginal(., type="density", groupFill=T, groupColour=T)


################################################################################
# color tf
################################################################################

(
  ggplot(
    alldeinfo.concordance %>%
      # Filter for significance
      filter(pvalue_TGFB1_ds5_vs_5E_ds5 <= 0.05) %>%
      # Bin STAT2 into desired categories
      dplyr::mutate(
        tfbin = cut(
          STAT2,
          breaks = c(-Inf, 0, 5, 10, 20),
          labels = c("0", "05", "510", "1020"),
          right = TRUE
        )
      ),
    aes(
      x = log2FC_TGFB1_ds5_vs_5E_ds5,
      y = log2FC_TGFB2_ds5_vs_5E_ds5,
      colour = factor(tfbin)
    )
  ) +
    geom_point()+scale_color_manual(values=c("0"="black", "05"="dark violet", "510"="dark orange", "1020"="yellow"))
) %>%
  ggMarginal(type = "density", groupFill = TRUE, groupColour = TRUE)  

################################################################################
# color concordance
################################################################################


(
  ggplot(
    alldeinfo.concordance %>%
      # Filter for significance
      filter(pvalue_TGFB1_ds5_vs_5E_ds5 <= 0.05) %>%
      # Bin STAT2 into desired categories
      dplyr::mutate(
        tfbin = cut(
          STAT2,
          breaks = c(-Inf, 0, 5, 10, 20),
          labels = c("0", "05", "510", "1020"),
          right = TRUE
        )
      ),
    aes(
      x = log2FC_TGFB1_ds5_vs_5E_ds5,
      y = log2FC_TGFB2_ds5_vs_5E_ds5,
      colour = factor(concordance)
    )
  ) +
    geom_point()
) %>%
  ggMarginal(type = "density", groupFill = TRUE, groupColour = TRUE)  


allplots.tgfb.g0=lapply(tfs, function(tff){
plt=xyplot(alldeinfo.concordance %>%
      filter(pvalue_TGFB2_ds5_vs_5E_ds5 <= 0.05 | pvalue_TGFB1_ds5_vs_5E_ds5 <= 0.05) %>% 
        dplyr::mutate( tfbinary=!!sym(tff)>0)
      , x="log2FC_TGFB1_ds5_vs_5E_ds5", y= "log2FC_TGFB2_ds5_vs_5E_ds5", colorby="tfbinary", title=tff )
plt
})



allplots.il41=lapply(tfs, function(tff){
plt=xyplot(alldeinfo.concordance %>%
      # Filter for significance
      filter(pvalue_IL41_ds5_vs_5E_ds5 <= 0.05 | pvalue_IL42_ds5_vs_5E_ds5 <= 0.05) %>%
      # Bin STAT2 into desired categories
      dplyr::mutate(
        tfbin = cut(
          !!sym(tff),
          breaks = c(-Inf, 0, 5, 10, Inf),
          labels = c("0", "05", "510", "1020"),
          right = TRUE
        )
      ), x="log2FC_IL41_ds5_vs_5E_ds5", y= "log2FC_IL42_ds5_vs_5E_ds5", colorby="concordance", title=tff )
plt
})



n <- length(allplots)              # number of plots
ncoll <- ceiling(sqrt(n))            # number of columns
nroww <- ceiling(n / ncoll)           # number of rows

cowplot::plot_grid(plotlist = allplots, ncol = ncoll, nrow = nroww)
    



  
dump.table(concordance_peakinfo)

#gathering mothifs present at each peak (all peaks)
get.concordance=Vectorize(function(Geneid) {
  
  x=names(mw$concordance.peaks.unique)[lapply(mw$concordance.peaks.unique, function(x) Geneid %in% x) %>% Reduce(c, .)]

if(length(x)>0 && length(x)<2){return(x)}else{return(NA)}
  }, USE.NAMES=F)

closest.tss.all=mw$closest_tss_global %>% as.data.frame %>% col2names(., "Geneid")

tfs=c("STAT1", "STAT2", "IRF2", "IRF8", "FOXG1", "ERG", "FLI1", "ETS2", "CPEB1", "OVOL2", "HXA9", "SOX5", "PROP1", "SOX15", "HXD12", "HXD11", "UNC4", "DLX3", "FOXJ3", "ZFP82", "ANDR", "NFAC1", "PRDM6", "ARI3A", "IRF3", "RUNX1", "RUNX3", "MNX1", "BC11A", "ZN394", "ZN713", "HXA11", "PO3F4", "GATA5", "MNX1", "LMX1B", "ONEC2", "PO3F3","FOXD2", "IRF7", "SMCA1", "NFAC2", "PEBB", "EHF" ) %>% unique



pks=rownames(mw$mtf_mat_gathered) 
all_peak_deinfo=(annotation.peaks[pks, ] , closest.tss.all[pks,  ] %>% select(-Geneid), mw$mtf_mat_gathered[pks, tfs], (allcomps[["all peaks")[pks, ] ) %>% Reduce(cbind, .)
  

  
dump.table(all_peak_deinfo)



```


```{bash}
source /opt/conda/etc/profile.d/conda.sh
conda activate py37

$DEEPTOOLSDIR
```



```{bash}

source /opt/conda/etc/profile.d/conda.sh
conda activate py37

bash /home/rstudio/mnt_out/deeptoolsrerun/2025-05-14_deeptools_ref_Ery_rbc.combo_5E_8G_IL4-1_IL4-2_TGF-1_TGF-2_concordance.peaks.onmerged3/run_deeptoolsinternal.sh



```


# 32. direct analysis of motif frequencies between the concordant, discordant peaks

```{r, fig.width=4, fig.height=4}
## comparing motifs in discordant peaks vs concordant peaks

test.df=test.tfbs.enrichment(get.deeptools.cluster.peaks(peak.clustering.workflow.result, cluster="cluster_4"), mtf_mat_gathered=mtf_mat_gathered,mtf.props.list=mtf.props.list, background.peaks=comparison.signal.peaks$Ery, filtered=F) %>% dplyr::mutate(diffrence=frequency.in.target-frequency.in.bg, sumratio=rawsums.target/rawsums.rest) 

contrast.plot=ggplot(test.df,aes(x=frequency.in.target, y=log2(fold.enrichment.bg), color=-log10(fisher.pvalue.contrast)))+geom_point()+
  scale_color_viridis(option="B",  name="-log10(Fisher p-value)")+
  geom_text_repel(data=test.df %>% filter((abs(frequency.in.target-frequency.in.bg)>=.15)), color="#ED6925FF", aes(label=gene_symbol), max.overlaps=50, min.segment.length = .02)+
xlab("% discordant regions with motif")+ylab("log2(Fold enrichment) vs concordant open")+
  theme_classic()

contrast.plot %>% stdplot(., "pointplot_absolute_relative_changes", w=1.8, h=1)


################################################################################
#new gene sets using only tfs of each gene set
################################################################################
gsetpars=load.gene.signatures()
gsetpars.mtf=load.gene.signatures()
is.mtf.tf= function(x) ifelse(x %in% colnames(mtf_mat_gathered), T, F)
filter.geneset= function(geneset, term, ...) geneset[geneset %>% names %>% grep(term, ., value=T, ...)]

gsetpars.mtf[16:19]=gsetpars.mtf[11:14]
gsetpars.mtf[[16]]$set$genesets= lapply(gsetpars.mtf[[16]]$set$genesets, function(x) x[is.mtf.tf(x)])
gsetpars.mtf[[17]]$set$genesets= lapply(gsetpars.mtf[[17]]$set$genesets, function(x) x[is.mtf.tf(x)])
gsetpars.mtf[[18]]$set$genesets= lapply(gsetpars.mtf[[18]]$set$genesets, function(x) x[is.mtf.tf(x)])
gsetpars.mtf[[19]]$set$genesets= lapply(gsetpars.mtf[[19]]$set$genesets, function(x) x[is.mtf.tf(x)])


human.cell.lines <- c(
  "A375",    # Malignant melanoma
  "A549",    # Lung carcinoma
  "BT20",    # Breast carcinoma
  "HCC515",  # Lung adenocarcinoma
  "HEPG2",   # Hepatocellular carcinoma
  "HT29",    # Colorectal adenocarcinoma
  "MCF7",    # Breast adenocarcinoma
  "PC3",     # Prostate adenocarcinoma
  "SKL",     # Glioblastoma
  "HA1E",    # Embryonic kidney-derived
  "HUVEC",   # Umbilical vein endothelial cells
  "NHDF",    # Dermal fibroblasts
  "K562",    # Chronic myelogenous leukemia
  "THP1",    # Monocytic leukemia
  "VCAP"     # Prostate carcinoma
)

"A375|A549|BT20|HCC515|HEPG2|HT29|MCF7|PC3|SKL|HA1E|HUVEC|NHDF|K562|THP1|VCAP"
human.cell.lines.string="HA1E|HUVEC|NHDF|pbmc|keratinocyte|epithelial|entometrial|dendritic|mesenchymal|endothelial|PBMC|smooth muscle"
concentration="50ng|100ng|150ng|200ng|400ng"

gsetpars.mtf[[16]]$set$genesets= filter.geneset(gsetpars.mtf[[16]]$set$genesets, "cancer", invert=T) %>% filter.geneset(., human.cell.lines.string) 
gsetpars.mtf[[17]]$set$genesets= filter.geneset(gsetpars.mtf[[17]]$set$genesets, "cancer", invert=T) %>% filter.geneset(. , human.cell.lines.string) 
gsetpars.mtf[[18]]$set$genesets= filter.geneset(gsetpars.mtf[[18]]$set$genesets , human.cell.lines.string)  %>% filter.geneset(., "4H")  %>% filter.geneset(., concentration)
gsetpars.mtf[[19]]$set$genesets= filter.geneset(gsetpars.mtf[[19]]$set$genesets , human.cell.lines.string)  %>% filter.geneset(., "4H")  %>% filter.geneset(., concentration)





gsetpars.mtf[[16]]$set$genesets=gsetpars.mtf[[16]]$set$genesets[lapply(gsetpars.mtf[[16]]$set$genesets, function(x) length(x)>1) %>% unlist]
gsetpars.mtf[[17]]$set$genesets=gsetpars.mtf[[17]]$set$genesets[lapply(gsetpars.mtf[[17]]$set$genesets, function(x) length(x)>1) %>% unlist]
gsetpars.mtf[[18]]$set$genesets=gsetpars.mtf[[18]]$set$genesets[lapply(gsetpars.mtf[[18]]$set$genesets, function(x) length(x)>1) %>% unlist]
gsetpars.mtf[[19]]$set$genesets=gsetpars.mtf[[19]]$set$genesets[lapply(gsetpars.mtf[[19]]$set$genesets, function(x) length(x)>1) %>% unlist]



min.frequency=0.40

simpleCache("enriched.motifs.df" %>% addversion, {
  

enriched.motifs.df=test.df %>% dplyr::filter(fold.enrichment.bg>1, frequency.in.target>=min.frequency, fisher.pvalue.contrast<=0.05) %>% dplyr::mutate(stat=-log2(fisher.pvalue.contrast)*frequency.in.target) %>% arrange(-stat) %>% select(gene_symbol, fisher.pvalue.contrast, stat, frequency.in.target)


enriched.motifs.df  }, assignToVar="enriched.motifs.df", recreate=T)

dump.table(enriched.motifs.df)

simpleCache("gsea_enriched_motifs_collective" %>% addversion, {
enriched.motifs.list=list(
  
  stat=enriched.motifs.df %>% pull(gene_symbol)

  )
eml=get.hyper.enrichments(enriched.motifs.list,gsetpars=gsetpars.mtf[16:19], background=676, make.barplot=T, numbars=10)


gsea.motifs.collective=eml
dump.table(gsea.motifs.collective)

eml
}, assignToVar="gsea.motifs.collective", recreate=T)


make.hyper.barplot(gsea.motifs.collective, genesets=c("LIGPERTDOWN", "LIGPERTLINCSDN","LIGPERTUP", "LIGPERTLINCSUP"), color="#9ecae1", numbars=12) %>% stdplot(., title=paste0("barplot_gsea_enrichedmotifs_minfreq", min.frequency), w=4, h=1)

dump.table(eml)

################################################################################
# Fig 4 b plot motif frequencies between the concordant peaks and the discordant peaks
################################################################################

contrast.plot.freq=ggplot(test.df,aes(y=frequency.in.target, x=frequency.in.bg, color=-log10(fisher.pvalue.contrast)))+geom_point()+
  #scale_color_gradient(low="grey", high="red", name="-log10(Fisher p-value)")+
  scale_color_viridis(option="B",  name="-log10(Fisher p-value)")+
  geom_text_repel(data=test.df %>% filter(((abs(frequency.in.target-frequency.in.bg)>=.15)| gene_symbol %in% enriched.motifs.list$stat)), color="#ED6925FF", aes(label=gene_symbol), max.overlaps=50, min.segment.length = .02)+
xlab("% Ery regions with motif")+ylab("% Discordant regions with motif")+geom_abline(slope=1, intercept=0, color="grey")+
  theme_classic()

contrast.plot.freq %>% stdplot(., "pointplot_absolute_relative_changes_freqbg_freqtarget", w=1.8, h=1)


################################################################################
# Fig 4 d plot correspondences between gene sets and hits 
################################################################################


has.molecule=function(dd, x, display=NULL){ 
  newvar=ifelse(!is.null(display), display, x)
  dd %>% dplyr::mutate(!!newvar:=ifelse(grepl(x, geneset, ignore.case=T),  ifelse(!is.null(display), display, x), F))
}

geneset.to.df=function(gset) lapply(1:length(gset), function(x) if(length(gset[[x]])==0) NULL else  as.data.frame(list(gene_symbol=gset[[x]], geneset=names(gset)[x]))) %>% Reduce(rbind, .) %>% dplyr::mutate(is.target=gene_symbol %in% !!enriched.motifs.list$stat)

df= geneset.to.df(gsetpars.mtf[[16]]$set$genesets) %>% has.molecule("interleukin-1|interleukin 1|il1", display="IL1") %>% has.molecule("testosterone") %>% has.molecule("estradiol") %>% has.molecule("calcitriol") %>% has.molecule("interleukin 4|interleukin-4|il4", display="Il4") %>% has.molecule("TGF-beta1", display="TGF_beta")

dfp=df %>% pivot_longer(., c("IL1","testosterone", "estradiol","calcitriol", "Il4", "TGF_beta"), names_to="molecule", values_to="status") %>% filter(status!=FALSE) 

dff=dfp %>% group_split(molecule) %>% lapply(., function(x)  list(molecule=unique(x$molecule), num.genesets=as.numeric(length(unique(x$geneset))), num.unique.genes=as.numeric(length(unique(x$gene_symbol))), num.genes=as.numeric(length(x$gene_symbol) ))  %>% as.data.frame) %>% Reduce(rbind, .)

dff=dff %>%  dplyr::mutate(unique.genes.per.geneset=as.numeric(num.unique.genes)/as.numeric(num.genesets), genes.per.geneset=as.numeric(num.genes)/as.numeric(num.genesets), percentage.genes=as.numeric(num.unique.genes)/ length(enriched.motifs.list$stat), num.genes.per.geneset=as.numeric(num.genes)/as.numeric(num.genesets)) 

(ggplot(dfp %>% dplyr::filter(gene_symbol %in% enriched.motifs.list$stat) , aes(fill=molecule, x=gene_symbol))+geom_bar()+theme_classic()+scale_fill_manual(values=brewer.pal(6, "Set2"))+rotatex(90)) %>% stdplot(., title="barplot_genes_vs_genesets")

ggplot(df  %>% filter(is.target) %>% group_by(testosterone, IL1, estradiol, calcitriol,Il4) %>% summarise(counts=n()) %>% dplyr::mutate(category=paste_(testosterone, IL1, estradiol, calcitriol,Il4)), aes(x=category, y=counts))+geom_col()+rotatex(90)



ranks <- discgenes %>%
  arrange((gene_dist)) %>%   # Ensure genes are ranked by stat in descending order
  with(setNames(gene_dist, gene_symbol))  # Create a named vector: names are gene symbols

# Subset the gene sets from gsetpars
selected_gene_sets <- gsetpars[11:14]

# Perform GSEA using fgsea
fgsea_results <- fgseaSimple(
  pathways = gsetpars[[11]]$set$genesets,  # Gene sets
  stats = ranks ,                 # Ranked gene list
  #minSize = 15,                  # Minimum size of a gene set to test
  #maxSize = 500, 
  scoreType="pos",# Maximum size of a gene set to test
  nperm = 1000                   # Number of permutations
)

# View significant results (adjusted p-value < 0.05)
significant_results <- fgsea_results %>%
  filter(pval < 0.05)

# Print or explore the results
print(significant_results)

# Example plot of enrichment for a specific pathway
plotEnrichment(selected_gene_sets[[1]], ranks) +
  labs(title = "Enrichment Plot for Pathway 16")

simpleCache("discordant.motif.correlations" %>% addversion, {
cordif=motif.correlation.diff.clustering(discordant.peaks, concordant.peaks, enriched.motifs.df$gene_symbol)
cordif
}, assignToVar="cordif", reload=T)


################################################################################
# enrichment perturbations that affect downstream targets
################################################################################
lim=2000
simpleCache(paste0("gsea.discordant.targets.maxdistance.from.tss.", lim) %>%addversion, {
discgenes=get.closest.tss(discordant.peaks, limit=2000)

emg=get.hyper.enrichments(list(discordant.genes=discgenes), gsetpars=gsetpars[11:14])
gsea.enrichments.discordant.targets=emg
dump.table(gsea.enrichments.discordant.targets)
gsea.enrichments.discordant.targets
}, assignToVar="gsea.enrichments.discordant.targets", reload=T)

make.hyper.barplot(emg, color="darkorange", genesets = c("LIGPERTDOWN", "LIGPERTLINCSDN","LIGPERTUP", "LIGPERTLINCSUP"), numbars=5) %>% stdplot(., "gsea_targets_discordant_allgenesglobal", w=4, h=.6)


emh=get.hyper.enrichments(cordif$grouplist,gsetpars=gsetpars[16:19], background=676, make.barplot=T)
emc=get.hyper.enrichments(cordif$grouplist,gsetpars=gsetpars[16:19], background=676, make.barplot=T)

simpleCache("gsea.motifs.clustered" %>% addversion, {
emm=get.hyper.enrichments(cordif$grouplist,gsetpars=gsetpars.mtf[16:19], background=676, numbars=10, make.barplot=T)

gsea.motifs.clustered=emm
gsea.motifs.clustered
}, assignToVar="gsea.motifs.clustered", reload=T)

dump.table(gsea.motifs.clustered)


make.hyper.barplot(emm) %>% stdplot(., title=paste("barplot_enrichments_residual_correlations_stat_freqabove_", min.frequency, sep="_") %>% addversion, w=2, h=3)


cordif$cormat %>% simple.heatmap(., )annotation_col=cordif$annotmat %>% select(motif.clusters), annotation_row=cordif$annotmat %>% select(motif.clusters), annotation_colors=allcolors, breaks=brks, col=cmap) %>% stdplot(., title="heatmap_residualcorrelation_discordant-ery_lead", w=ww, h=hh)


ord=test.df %>% filter( abs(log2(fold.enrichment.bg))>=1) %>% dplyr::mutate(higher=ifelse(diffrence>=0, T, F)) %>% group_split(higher) %>% lapply(., function(x) x %>% arrange(frequency.in.bg) %>% pull(gene_symbol) ) %>% Reduce(c, .)

### make all frequencies into one variable
freq.df= test.df %>% dplyr::filter(gene_symbol %in% ord) %>%pivot_longer(., c("frequency.in.target", "frequency.in.bg", "frequency.global"), names_to="peak_set", values_to="frequency")

sum.df= test.df  %>%pivot_longer(., c("rawsums.target", "rawsums.rest", "rawsums.all"), names_to="peak_set", values_to="avg.motifs.per.peak")

ggplot(freq.df, aes(x=peak_set, y=factor(gene_symbol, levels=ord), size=frequency, fill=diffrence))+geom_point(shape=21, alpha=0.5)+scale_fill_gradient2(low="blue", mid = "grey", high="red")+scale_x_discrete(labels=c("All peaks", "Concordant","Discordant"))+theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = .5))

ggplot(freq.df, aes(x=peak_set, y=factor(gene_symbol, levels=ord), size=, fill=diffrence))+geom_point(shape=21, alpha=0.5)+scale_fill_gradient2(low="blue", mid = "grey", high="red")+scale_x_discrete(labels=c("Concordant","Discordant"))+theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = .5))



ggplot(test.df, aes(x=-log(frequency.in.bg), y=-log(frequency.in.target), size=as.numeric(rawsums.target)/as.numeric(rawsums.rest), color="none", fill=frequency.in.target-frequency.in.bg, label=gene_symbol))+geom_point(shape=21, alpha=0.5)+geom_abline(slope=1, intercept=0)+scale_fill_gradient2(low = "blue", mid="grey", high="red")+theme_classic()
```



Analyse presence or absence of priority tfs
```{r}

tfs=c("STAT1", "STAT2", "IRF2", "IRF8", "FOXG1", "ERG", "FLI1", "ETS2", "CPEB1", "OVOL2", "HXA9", "SOX5", "PROP1", "SOX15", "HXD12", "HXD11", "UNC4", "DLX3", "FOXJ3", "ZFP82", "ANDR", "NFAC1", "PRDM6", "ARI3A", "IRF3", "RUNX1", "RUNX3", "MNX1", "BC11A", "ZN394", "ZN713", "HXA11", "PO3F4", "GATA5", "MNX1", "LMX1B", "ONEC2", "PO3F3","FOXD2", "IRF7", "SMCA1", "NFAC2", "PEBB", "EHF" ) %>% unique



ctfmat=mw$mtf_mat_gathered[intersect( lapply(concordance.peaks.unique , function(x) unique(x)) %>% Reduce(c,.), rownames(mw$mtf_mat_gathered)), tfs]>0

rannot=rownames(ctfmat) %>% vector.as.df %>% dplyr::rename(Geneid=value) %>% dplyr::mutate(concordance=check.concordance(Geneid), is.signif= Geneid %in% c(cp, dp))

hm=simple.heatmap(ctfmat, annotation_row=rannot, cluster_cols=T, cluster_rows=T)
sca=5
tpdf("heatmapallpeaks", wi=pw*sca, he=pw*sca)
print(hm)
dev.off()




tfs=c("STAT1", "STAT2", "IRF2", "IRF8", "FOXG1", "ERG", "FLI1",  "FOXG1") %>% unique


tilecols=c("purple", "orange")
cp=chits$TGFB1_ds5 %>% filter(concordance=="concordant.open") %>% pull(Geneid)
dp=hits$TGFB1_ds5 %>% filter(concordance=="discordant") %>% pull(Geneid)


sign.annot=hits$TGFB1_ds5 %>% filter(Geneid %in% c(cp, dp)) %>% col2names(., "Geneid") %>% select(concordance,log2FoldChange, baseMean)
sign.annot$mean.5E=vsd[c(cp,dp), get.experiments("5E_ds5", metadata.alldatasets.formatted)] %>% rowMeans
sign.annot$mean.tgfb1=vsd[c(cp,dp), get.experiments("TGFB1_ds5", metadata.alldatasets.formatted)] %>% rowMeans


simple.heatmap(apply(mw$mtf_mat_gathered[c(cp,dp),, drop=F], 1, function(x)  tfs %in% names(x[x>0]) ) %>% giverownames(., tfs) %>% t %>% seriatecols,cluster_rows=T, cluster_cols=T, annotation_row=sign.annot, col=tilecols,annotation_colors=append(allcolors, list(log2FoldChange=colorRampPalette(c("blue", "white", "red"))(30))   ))

```



facs plot round 3 prediction validation

```{r}


reagentplot=ggplot(meta %>% filter(dsname %in% test.datasets) %>% pivot_longer(cols=c("epo.1", "insulin.heparin.1", "hydrocortisone.1"), names_to="reagent", values_to="amount") %>% filter(amount>0) , aes(x=factor(condition), y=factor(reagent), size=amount))+
  geom_point()+
  scale_size_continuous(range = c(1, 3)) +
  theme_classic()+
   xlab("Condition")+
 ylab("Reagent")


sz1=3
facsdata3.day11=read.csv("~/metadata/2025_02_FACS_results_Day_1_VE2.csv", header=T, skip=1) %>% fixnames %>% as.data.frame

vec=facsdata3.day11$Treatment %>% unique
combs=combn(vec, 2) %>% t
comparisons=pairs.from.vectors(combs[, 1], combs[, 2])[1:5]

pl3671=ggplot(facsdata3.day11, aes(x=Treatment, y=as.numeric(cd36.cd71)))+geom_point(shape=24, color="black", size=sz1)+
  cowplot::theme_cowplot()+
  cowplot::background_grid()+
  #ylim(c(0,100))+
  ylab("% CD36+ CD71+ cells")+
  xlab("Treatment")+
   geom_signif(comparisons=comparisons, y_position=1:length(comparisons),  map_signif_level=F, na.rm=T)

pl235a71=ggplot(facsdata3.day11, aes(x=Treatment, y=cd235a.cd71))+geom_point(shape=24, color="black", size=sz1)+
  cowplot::theme_cowplot()+
  cowplot::background_grid()+
  #ylim(c(0,100))+
  ylab("% CD235a+ CD71+ cells")+
  xlab("Treatment")

pl235a=ggplot(facsdata3.day11, aes(x=Treatment, y=cd235a))+geom_point(shape=24, color="black", size=sz1)+
  cowplot::theme_cowplot()+
  cowplot::background_grid()+
  #ylim(c(0,100))+
  ylab("% CD235a cells")+
  xlab("Treatment")

pl235a.median=ggplot(facsdata3.day11, aes(x=Treatment, y=cd235a.median))+geom_point(shape=24, color="black", size=sz1)+
  cowplot::theme_cowplot()+
  cowplot::background_grid()+
  #ylim(c(0,100))+
  ylab("CD235a median in cd235a cd71")+
  xlab("Treatment")

pl235a.median=ggplot(facsdata3.day11, aes(x=Treatment, y=cd235a.median))+geom_point(shape=24, color="black", size=sz1)+
  cowplot::theme_cowplot()+
  cowplot::background_grid()+
  #ylim(c(0,100))+
  ylab("CD235a median in cd235a cd71")+
  xlab("Treatment")

pl36=ggplot(facsdata3.day11, aes(x=Treatment, y=cd36.median))+geom_point(shape=24, color="black", size=sz1)+
  cowplot::theme_cowplot()+
  cowplot::background_grid()+
  #ylim(c(0,100))+
  ylab("CD36 median in cd36a cd71")+
  xlab("Treatment")

pl71=ggplot(facsdata3.day11, aes(x=Treatment, y=cd71.median))+geom_point(shape=24, color="black", size=sz1)+
  cowplot::theme_cowplot()+
  cowplot::background_grid()+
  #ylim(c(0,100))+
  ylab("CD71 median in cd36a cd71")+
  xlab("Treatment")

plratio7136=ggplot(facsdata3.day11, aes(x=Treatment, y=cd71.median/cd36.median))+geom_point(shape=24, color="black", size=sz1)+
  cowplot::theme_cowplot()+
  cowplot::background_grid()+
  #ylim(c(0,100))+
  ylab("CD71/cd36 ratio in cd36a cd71")+
  xlab("Treatment")

ggplot(facsdata %>% dplyr::mutate(rbc.round1=factor(Condition)), aes(x=CD36.CD71..subset.Median.CD36, y=CD36.CD71.subset.Median.CD71))+geom_point(aes(color=rbc.round1))+scale_color_manual(values=allcolors$rbc.round1)


ggplot(facsdata %>% dplyr::mutate(rbc.round1=factor(Condition), rtio=CD36.CD71.subset.Median.CD71/CD36.CD71..subset.Median.CD36), aes(x=Condition, y=CD36.CD71.subset.Freq.of.Parent))+geom_jitter(aes( size=rtio), width=.1)#+scale_color_manual(values=allcolors$rbc.round1)#+scale_color_manual(values=allcolors$rbc.round1)


facsdataround1=facsdata %>% dplyr::mutate(rbc.round1=Condition, rtio=CD36.CD71.subset.Median.CD71/CD36.CD71..subset.Median.CD36, pop.ratio=CD36.CD71.subset.Freq.of.Parent/CD71.subset.Freq.of.Parent)

dump.table(facsdataround1)

ggplot(facsdataround1, aes(y=rtio, x=CD36.CD71.subset.Freq.of.Parent, color=factor(rbc.round1)))+geom_point(aes(size=pop.ratio))+scale_color_manual(values=allcolors$rbc.round1)
sca=1.3
rr=600

layout=
"AAAAAA
AAAAAA
AAAAAA
BBBBBB"

fd=facsdata %>% group_by(Condition) %>% summarise(mn=mean(CD36.CD71.subset.Freq.of.Parent), sdev=sd(CD36.CD71.subset.Freq.of.Parent), minn=min(CD36.CD71.subset.Freq.of.Parent), ymax=max(CD36.CD71.subset.Freq.of.Parent), CD36.CD71.subset.Freq.of.Parent=minn)

facsplot=ggplot(facsdataround1, aes(x=factor(Condition), y=CD36.CD71.subset.Freq.of.Parent))+
  geom_point(aes(fill=factor(Condition)), shape=24, color="black", size=sz1)+
  geom_segment(data=fd, aes(xend=factor(Condition), yend=ymax), color="black")+
  #geom_errorbar(aes(ymin=mn-sdev, ymax=mn+sdev))+
  #geom_col(fill="cyan", color="black")+geom_errorbar(aes(ymin=mn-sdev, ymax=mn+sdev))+
  scale_fill_manual(values=allcolors$rbc.round1)+
  cowplot::theme_cowplot()+
  cowplot::background_grid()+
  #ylim(c(0,100))+
  ylab("% CD36+ CD71+ cells")+
  xlab("EDM1 Treatment")

pan=wrap_plots(A =facsplot , B = reagentplot,
                   design = layout)
tpdf(path=config$plotpath, paste0("fig2_triangleplot_facs_EDM1_vs_percentcd36cd71_analysisversion_", analysis.version), he=pw*sca, wi=pw*sca*1.5)
print(pan)
dev.off()

```



```{r}
tfannot=as.data.frame(cutree(as.hclust(column_dend(hmtf)), k=20)) %>% givecolnames(., nms="cluster") %>% dplyr::mutate(cluster=factor(cluster))

hmtf2=ComplexHeatmap::pheatmap(widemat2  , cluster_row=F, cluster_col=T, scale="none", breaks=seq(0,5,1), annotation_col=tfannot)


hmtf=ComplexHeatmap::pheatmap(widemat2  , cluster_row=F, cluster_col=T, scale="none", breaks=seq(0,5,1))

cortfhm=ComplexHeatmap::pheatmap(corr.tfs, annotation_row=tfannot, annotation_col=tfannot)
ggplot(gradual.enrichments %>% Reduce(rbind, .) , aes(x=target, y=fold.enrichment, color=gene_symbol))+geom_line()+NoLegend()

pkl=peak.clustering.workflow.result$peak.clustering.result$peak.list
pkl.high=lapply(pkl, function(x) x %>% head(round(length(x)/2)))
pkl.low=lapply(pkl, function(x) x %>% head(round(length(x)/2)))

tfbs.result=test.tfbs.enrichment.list(, mtf_mat_gathered)


tfbs.result.high=test.tfbs.enrichment.list(peak.clustering.workflow.result$peak.clustering.result$peak.list, mtf_mat_gathered)

joint.peaklists=peak.clustering.workflow.result$peak.clustering.result$peak.list[4:8] %>% Reduce(c,.)
tfbs.result.joint=test.tfbs.enrichment(joint.peaklists, mtf_mat_gathered)

deeptools.tmnt.clusteredpeaks=prepare.deeptools.script(test.class.variable="tmnt.full", ref.sample.number=2, max.test.samples=10,norm.peak.vals=norm.peak.vals,meta=meta, test.class=chosen.condition, dataset.info=dataset.info, peak.list=peak.clustering.workflow.result$peak.clustering.result$peak.list,peaks.id = paste0("clustered_peaks_workflow_winner_auc_", auc.thresh) %>% addversion, heatmap.height=28, sort.using.samples=3, num.processors=10)


```



DEseq2 of all combinations of te verification round

```{r}

allinvitro= colData(dds) %>% as.data.frame %>% dplyr::filter((Experiment %in%  test.ids.list[[k]])|grepl(ref,!!sym(refvar)) ) %>% arrange(round) %>% pull(Experiment)
positives.validation=make.class.target.list(meta4[allinvitro, , drop=F], "Condition")


meta2=meta2  %>% dplyr::mutate(Condition=ifelse(tmnt.full=="NANANANANA_NANANANANA", celltype, ifelse(is.na(rbc.combo), tmnt.full, ifelse(!grepl("Round", rbc.combo), rbc.combo, tmnt.full))))

colData(dds)=DataFrame(meta2)


allinvitro= colData(dds) %>% as.data.frame %>% dplyr::filter(grepl("Ve2",Experiment) ) %>% arrange(round) %>% pull(Experiment)

#dds.invitro= dds[,allinvitro] #case 1: include all peaks
dds.invitro= dds[Reduce(c, concordance.peaks) %>% unique ,allinvitro] #case 2: only include concordance peaks in the DE calculation

par.deseq2.invitro.eachvsall=parallel::mclapply(1:length(positives.validation), function(x, dd, allpos, pd){
  
  lab=names(allpos)[x]
  classvar=allpos[[x]]$classvar
  levs=c(lab, "Rest")
  is.target= function(x, targets) fifelse(x %in% targets, levs[1], levs[2])
  
  
simpleCache::simpleCache(paste0("deseq2_invitro_validate_target-",lab, "_vsrest_positivesid", digest::digest(allpos),"_ddsid_",digest::digest(dd),  "analysis", analysis.version), {

dd[["target_vs_rest"]] <- factor(is.target(dd[[classvar]], allpos[[x]]$targets), levels=levs)

# Re-run the DESeq pipeline with the new condition
design(dd) <- ~target_vs_rest
dd <- DESeq(dd)  
res <- results(dd, contrast = c("target_vs_rest", levs[1], levs[2]))  

 }, assignToVar="res", reload=T)
  
  
  },allpos=positives.validation,dd=dds.invitro, mc.cores=10, mc.cleanup=T) %>% givename(., names(positives.validation))




################################################################################
# performing  comparisons of every condition above to erythroblasts
################################################################################




lst.v=targeted.changes.analysis(all.des[c("8Gv","8G","5E","TGF-1v","TGF-2v","IL4-1v","IL4-2v")], concordance.peaks, pval=0.05, thr=0.2, facet="type")


lst.v$plot.effectsizes


```

Find the direct differences to Ery
```{r}

#separate batch comparison digest
dig="d473205e32c19727d8ee0e852d4c7182"
#dig=digest::digest(all.des)
simpleCache(paste0("de.among.conditions_desid_", dig) %>% addversion, {
DE.among.conditions=lst.v$df %>% dplyr::filter(grepl("v$", treatment)) %>% pivot_wider(., names_from="treatment", values_from="log2FoldChange", id_cols=c("Geneid", "concordance")) %>% arrange(`5Ev`)
DE.among.conditions
}, assignToVar="DE.among.conditions", reload=T)

bin.DE <- function(x) {
  if(class(x)!="numeric"){
  x
    }else{
    
  cut(na2zero(x),
      breaks = c(-Inf, -4, -3, -2, -1, 1, 2, 3, 4, Inf),
      labels = c("-4", "-3", "-2", "-1", "no DA", "1", "2", "3", "4+"),
      right = FALSE, include.lowest = TRUE)
    }
}

bin.DE2 <- function(x) {
  if(class(x)!="numeric"){
  x
    }else{
    
  cut(na2zero(x),
      breaks = c(-Inf,-1, 1, Inf),
      labels = c("more closed", "no DA", "more open"),
      right = FALSE, include.lowest = TRUE)
    }
}





binned.dac=apply(DE.among.conditions[, 3:ncol(DE.among.conditions)], c(1,2), function(x) bin.DE2(as.numeric(x))) %>% cbind(DE.among.conditions[,c(1:2)], .) %>% as.data.frame



binned.dac$all.non.da=(apply(binned.dac[3:8], c(1,2), function(x) x=="no DA") %>% rowSums)==5
binned.dac3$all.non.da=(apply(binned.dac3[3:8], c(1,2), function(x) x=="no DA") %>% rowSums)==5

DE.among.conditions=lst.v$df %>% pivot_wider(., names_from="treatment", values_from="log2FoldChange", id_cols=c("Geneid", "concordance")) %>% arrange(`5E_ds3`)

binned.dac3=apply(DE.among.conditions[, 3:ncol(DE.among.conditions)], c(1,2), function(x) bin.DE3(as.numeric(x))) %>% cbind(DE.among.conditions[,c(1:2)], .) %>% as.data.frame

transferplot(df=binned.dac %>% dplyr::filter(!!sym("5Ev")!= "no DA"), labelvars=colnames(binned.dac)[c(2,4,6)] )
transferplot(df=binned.dac %>% dplyr::filter(!!sym("5Ev")!= "no DA"), labelvars=colnames(binned.dac)[c(2,4,5)]  )
transferplot(df=binned.dac %>% dplyr::filter(!!sym("5Ev")!= "no DA"), labelvars=colnames(binned.dac)[c(2,4,7)] )
transferplot(df=binned.dac %>% dplyr::filter(!!sym("5Ev")!= "no DA"), labelvars=colnames(binned.dac)[c(2,4,8)]  )

tpv=transferplot(df=binned.dac %>% dplyr::filter(!!sym("5Ev")!= "no DA"), labelvars=colnames(binned.dac)[c(2,4,8,7,5,6)]  )+theme_clean_minimal()+xlab("")+ylab("Frequency")
tp3=transferplot(df=binned.dac3 %>% dplyr::filter(!!sym("5E_ds3")!= "no DA"), labelvars=colnames(binned.dac)[c(2,4,8,7,5,6)]  )+theme_clean_minimal()+xlab("")+ylab("Frequency")
```




```{r}
tpl=list(
  one=transferplot(df=binned.dac %>% dplyr::filter(!!sym("5Ev")!= "no DA"), labelvars=colnames(binned.dac)[c(2,4)]  )+theme_clean_minimal()+xlab("")+ylab("Frequency")+NoLegend(),
  two=transferplot(df=binned.dac %>% dplyr::filter(!!sym("5Ev")!= "no DA"), labelvars=colnames(binned.dac)[c(2,8)]  )+theme_clean_minimal()+xlab("")+ylab("Frequency")+NoLegend(),
  three=transferplot(df=binned.dac %>% dplyr::filter(!!sym("5Ev")!= "no DA"), labelvars=colnames(binned.dac)[c(2,7)]  )+theme_clean_minimal()+xlab("")+ylab("Frequency")+NoLegend(),
  four=transferplot(df=binned.dac %>% dplyr::filter(!!sym("5Ev")!= "no DA"), labelvars=colnames(binned.dac)[c(2,5)]  )+theme_clean_minimal()+xlab("")+ylab("Frequency")+NoLegend(),
  five=transferplot(df=binned.dac %>% dplyr::filter(!!sym("5Ev")!= "no DA"), labelvars=colnames(binned.dac)[c(2,6)]  )+theme_clean_minimal()+xlab("")+ylab("Frequency")+NoLegend()
)

tpl %>% Reduce('+', .)

tpdf("transferplot_DE_among_conditions_validation", wi=pw*sca*2.5, he=pw*sca*1.2)
print(tpv)
dev.off()



#best at last place
transferplot(df=binned.dac %>% dplyr::filter(!all.non.da), labelvars=colnames(binned.dac)[c(2,4,5,8,7,6)]  )
transferplot(df=binned.dac %>% dplyr::filter(!all.non.da), labelvars=colnames(binned.dac)[c(2,6,7,8, 4,5)]  )



################################################################################
# table annotating the differential peaks for each validation and their closest
# genes
################################################################################
diff.concordance.annotated=lst.v$df %>% dplyr::mutate(Chr=get.annotation(Geneid, "Chr"), Start=get.annotation(Geneid, "Start"), End=get.annotation(Geneid, "End"))

DE_to_ery_concordancepeaks_validation_conditions_annotated= diff.concordant.annotated %>% left_join(., get.closest.tss.df(diff.concordant.annotated$Geneid, 200000), by="Geneid") %>% dplyr::mutate(closest.gene=gene_symbol, closest_gene_dist=gene_dist)


dump.table(DE_to_ery_concordancepeaks_validation_conditions_annotated)

```


```{r}

remove.narows=function(matt){

  if(length(dim(matt))<=1){
    print("Argument not a matrix. returning as is")
    matt
    }else{
    matt[!apply(matt, 1, is.na),]}

}

anrow=vector.list.to.df(concordance.peaks)$nodups %>% select(class) 

gaps.row= (anrow$class %>% table)[c("concordant.open","discordant", "concordant.closed")] %>% cumsum

#vsd[Reduce(c, concordance.peaks$discordant), allinvitro] %>% row.heatmap(., cluster_cols=T, main="discordant")
hm=vsd[rownames(anrow), allinvitro] %>% row.heatmap(., cluster_cols=T, main="concordant open and discordant", gaps_row=gaps.row[1:2], show_rownames=F, annotation_row=anrow, breaks=seq(-2,2,0.01))

tpdf(path=config$plotpath, "heatmap_concordantopen_discordant", he=pw*sca*2, wi=pw*sca)
print(hm)
dev.off()


vsd[Reduce(c, concordance.peaks$concordant.closed), allinvitro] %>% remove.zerorows %>% row.heatmap(., cluster_cols=T, cluster_rows=T, main="concordant closed")
```


Analyisis of relevant priority TFs in the context of hematopoietic development in single cells

```{r, fig.width=6, fig.height=3}

#import velten dataset
so=readRDS("~/mnt_data/external_datasets/velten97_wholetranscriptome.rds")
allcolors[["ct"]]=c(
  # HSC / multipotent
  `HSCs & MPPs` = "#DB1922",
  `Lymphomyeloid prog` = "#28FF3D",

  # Erythroid lineage
  `Erythro-myeloid progenitors` = "#E76DAA",
  `Early erythroid progenitor` = "#6C11BC",
  `Late erythroid progenitor` = "#B010AD",
  `Aberrant erythroid` = "#718FDF",

  # Granulocyte / myeloid lineage
  `Early promyelocytes` = "#30203A",
  `Late promyelocytes` = "#26BDC0",
  Myelocytes = "#B89B8A",
  `Eosinophil-basophil-mast cell progenitors` = "#FA3E31",
  `Megakaryocyte progenitors` = "#1918D9",

  # Dendritic cells
  `Conventional dendritic cell 1` = "#A987B6",
  `Conventional dendritic cell 2` = "#B0EC9A",
  `Plasmacytoid dendritic cell progenitors` = "#619EC8",
  `Plasmacytoid dendritic cells` = "#D13275",

  # Monocytes
  `Classical Monocytes` = "#F5FC21",
  `Non-classical monocytes` = "#8FFE79",

  # B-cell lineage
  `Pre-pro-B cells` = "#FA1515",
  `Pro-B cells` = "#E91054",
  `Pre-B cells` = "#B1914F",
  `Small pre-B cell` = "#2726E2",
  `Immature B cells` = "#1EB7F9",
  `Mature naive B cells` = "#623C6A",
  `Nonswitched memory B cells` = "#093D21",
  `Class switched memory B cells` = "#3E4436",
  `Plasma cells` = "#FB7C15",

  # T-cell lineage
  `CD4+ naive T cells` = "#59826A",
  `CD4+ memory T cells` = "#CBEE6F",
  `CD69+PD-1+ memory CD4+ T cells` = "#554557",

  `CD8+ naive T cells` = "#85E472",
  `CD8+ central memory T cells` = "#D27543",
  `CD8+ effector memory T cells` = "#8FFCDF",
  `CD8+CD103+ tissue resident memory T cells` = "#708B07",
  `GammaDelta T cells` = "#3BA578",

  # NK / NKT lineage
  `NK cell progenitors` = "#501743",
  `CD56brightCD16- NK cells` = "#847682",
  `CD56dimCD16+ NK cells` = "#DF55A2",
  `NK T cells` = "#2556EB"
)

tpdf("sclegend", wi=pw*sca*1.3, he=pw*sca*2)
print(manual.legend(allcolors, "ct", bar.width = 0.04))
dev.off()

rd="ProjectedUMAP"
rdk="Projected"
sz=0.005
ggu=ggumap(so, colorby="ct", labelby="none", reductions=rd, reduction.key = paste0(rdk,"_"), sz = sz, colorlist=allcolors)+NoLegend()
ggul=ggumap(so, colorby="ct", labelby="ct", reductions=rd, reduction.key = paste0(rdk, "_"), sz = sz, colorlist=allcolors)+NoLegend()

ntfs=c("IRF1","IRF2","IRF3", "IRF5",  "IRF7","IRF8", "STAT1", "STAT2","FLI1", "BCL11A", "ARID3A","ERG")

tfs.plot.list=FeaturePlot(so, features=ntfs, combine=F, reduction=rd, raster = T, cols=c("lightgrey", "black"))
 
                          #+scale_color_viridis(option="C")
    scplot=ggu+(lapply(tfs.plot.list,function(x) x+NoLegend()+NoAxes()+
    theme(plot.title = element_text(size = 10))) %>% Reduce('+', .)) 
 scplotl=ggul+(lapply(tfs.plot.list,function(x) x+NoLegend()+NoAxes()+
    theme(plot.title = element_text(size = 10))) %>% Reduce('+', .)) 
 sca=2
 tpdf("singlecellplot_nolabels", wi=pw*sca*1.5, he=pw*sca)
 print(scplot)
 dev.off()

 tpdf("singlecellplot_yeslabels", wi=pw*sca*1.5, he=pw*sca)
 print(scplotl)
 dev.off()
 
```




```{r}
sessionInfo()
```






